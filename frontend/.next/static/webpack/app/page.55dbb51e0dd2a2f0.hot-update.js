"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./utils/pageAudioManager.ts":
/*!***********************************!*\
  !*** ./utils/pageAudioManager.ts ***!
  \***********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   API_ENDPOINTS: () => (/* binding */ API_ENDPOINTS),\n/* harmony export */   convertSupabaseToLocal: () => (/* binding */ convertSupabaseToLocal),\n/* harmony export */   findActiveTranscriptEntry: () => (/* binding */ findActiveTranscriptEntry),\n/* harmony export */   loadTranscriptData: () => (/* binding */ loadTranscriptData),\n/* harmony export */   organizePageAudioFiles: () => (/* binding */ organizePageAudioFiles),\n/* harmony export */   parseAudioFilename: () => (/* binding */ parseAudioFilename),\n/* harmony export */   parseTranscriptContent: () => (/* binding */ parseTranscriptContent),\n/* harmony export */   parseTranscriptFilename: () => (/* binding */ parseTranscriptFilename),\n/* harmony export */   updateTranscriptActiveState: () => (/* binding */ updateTranscriptActiveState)\n/* harmony export */ });\n// File: frontend/utils/pageAudioManager.ts\n/**\r\n * Parses filename to extract chapter and page information\r\n * Expected format: ch{chapter}_page{page}_dialogue_{timestamp}.mp3\r\n * Example: ch01_page01_dialogue_20251018_220717.mp3\r\n */ function parseAudioFilename(filename) {\n    const match = filename.match(/ch(\\d+)_page(\\d+)_dialogue/);\n    if (!match) return null;\n    return {\n        chapterNumber: parseInt(match[1], 10),\n        pageNumber: parseInt(match[2], 10)\n    };\n}\n/**\r\n * Parses transcript filename to extract chapter and page information\r\n * Expected format: ch{chapter}_page{page}_transcript_{timestamp}.txt\r\n * Example: ch01_page01_transcript_20251018_220717.txt\r\n */ function parseTranscriptFilename(filename) {\n    const match = filename.match(/ch(\\d+)_page(\\d+)_transcript/);\n    if (!match) return null;\n    return {\n        chapterNumber: parseInt(match[1], 10),\n        pageNumber: parseInt(match[2], 10)\n    };\n}\n/**\r\n * Groups audio and transcript files by chapter and page\r\n */ function organizePageAudioFiles(audioFiles, transcriptFiles) {\n    let baseUrl = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : '/assets';\n    // Ensure we join baseUrl and filenames without producing protocol-relative URLs (e.g., //file)\n    const joinUrlPath = (root, filename)=>{\n        if (!root || root === '/') {\n            return \"/\".concat(filename);\n        }\n        const trimmed = root.endsWith('/') ? root.slice(0, -1) : root;\n        return \"\".concat(trimmed, \"/\").concat(filename);\n    };\n    const chaptersMap = new Map();\n    // Process audio files\n    audioFiles.forEach((filename)=>{\n        const parsed = parseAudioFilename(filename);\n        if (!parsed) return;\n        const { chapterNumber, pageNumber } = parsed;\n        if (!chaptersMap.has(chapterNumber)) {\n            chaptersMap.set(chapterNumber, new Map());\n        }\n        const chapterPages = chaptersMap.get(chapterNumber);\n        if (!chapterPages.has(pageNumber)) {\n            chapterPages.set(pageNumber, {\n                pageNumber,\n                chapterNumber,\n                audioUrl: '',\n                transcriptUrl: ''\n            });\n        }\n        chapterPages.get(pageNumber).audioUrl = joinUrlPath(baseUrl, filename);\n    });\n    // Process transcript files\n    transcriptFiles.forEach((filename)=>{\n        const parsed = parseTranscriptFilename(filename);\n        if (!parsed) return;\n        const { chapterNumber, pageNumber } = parsed;\n        if (!chaptersMap.has(chapterNumber)) {\n            chaptersMap.set(chapterNumber, new Map());\n        }\n        const chapterPages = chaptersMap.get(chapterNumber);\n        if (!chapterPages.has(pageNumber)) {\n            chapterPages.set(pageNumber, {\n                pageNumber,\n                chapterNumber,\n                audioUrl: '',\n                transcriptUrl: ''\n            });\n        }\n        chapterPages.get(pageNumber).transcriptUrl = joinUrlPath(baseUrl, filename);\n    });\n    // Convert to array format\n    const chapters = [];\n    chaptersMap.forEach((pages, chapterNumber)=>{\n        const pageArray = Array.from(pages.values()).sort((a, b)=>a.pageNumber - b.pageNumber);\n        chapters.push({\n            chapterNumber,\n            pages: pageArray,\n            totalPages: pageArray.length\n        });\n    });\n    const result = chapters.sort((a, b)=>a.chapterNumber - b.chapterNumber);\n    return result;\n}\n/**\r\n * Loads transcript data from URL\r\n */ async function loadTranscriptData(transcriptUrl) {\n    try {\n        const response = await fetch(transcriptUrl);\n        if (!response.ok) {\n            throw new Error(\"Failed to load transcript: \".concat(response.statusText));\n        }\n        const content = await response.text();\n        const parsed = parseTranscriptContent(content);\n        return parsed;\n    } catch (error) {\n        console.error('Error loading transcript:', error);\n        return [];\n    }\n}\n/**\r\n * Parses transcript content into structured entries\r\n */ function parseTranscriptContent(content) {\n    // Remove potential UTF-8 BOM and normalize line endings\n    const sanitized = content.replace(/^\\uFEFF/, '');\n    const lines = sanitized.split(/\\r?\\n/);\n    const entries = [];\n    lines.forEach((line, index)=>{\n        const trimmed = line.trim();\n        if (!trimmed) return;\n        // Allow leading spaces before timestamp and trailing spaces at end\n        const match = trimmed.match(/^\\s*(\\d{2}:\\d{2})\\s+(.+?):\\s+(.+)\\s*$/);\n        if (match) {\n            const [, timeStr, speaker, text] = match;\n            const [minutes, seconds] = timeStr.split(':').map(Number);\n            const timestamp = minutes * 60 + seconds;\n            entries.push({\n                id: \"entry-\".concat(index),\n                timestamp,\n                speaker: speaker.trim(),\n                text: text.trim(),\n                isActive: false\n            });\n        }\n    });\n    return entries;\n}\n/**\r\n * Finds the active transcript entry based on current time\r\n */ function findActiveTranscriptEntry(entries, currentTime) {\n    let activeEntry = null;\n    for(let i = 0; i < entries.length; i++){\n        const entry = entries[i];\n        const nextEntry = entries[i + 1];\n        if (currentTime >= entry.timestamp && (!nextEntry || currentTime < nextEntry.timestamp)) {\n            activeEntry = entry;\n            break;\n        }\n    }\n    return activeEntry;\n}\n/**\r\n * Updates active state for transcript entries\r\n */ function updateTranscriptActiveState(entries, currentTime) {\n    return entries.map((entry)=>{\n        var _entries_find;\n        return {\n            ...entry,\n            isActive: entry.timestamp <= currentTime && (((_entries_find = entries.find((e)=>e.timestamp > entry.timestamp)) === null || _entries_find === void 0 ? void 0 : _entries_find.timestamp) || Infinity) > currentTime\n        };\n    });\n}\n/**\r\n * Converts Supabase data to local format\r\n */ function convertSupabaseToLocal(supabaseData) {\n    const chaptersMap = new Map();\n    supabaseData.forEach((item)=>{\n        if (!chaptersMap.has(item.chapter_number)) {\n            chaptersMap.set(item.chapter_number, new Map());\n        }\n        const chapterPages = chaptersMap.get(item.chapter_number);\n        chapterPages.set(item.page_number, {\n            pageNumber: item.page_number,\n            chapterNumber: item.chapter_number,\n            audioUrl: item.audio_url,\n            transcriptUrl: item.transcript_url,\n            transcriptData: item.transcript_content ? parseTranscriptContent(item.transcript_content) : undefined,\n            duration: item.duration\n        });\n    });\n    const chapters = [];\n    chaptersMap.forEach((pages, chapterNumber)=>{\n        const pageArray = Array.from(pages.values()).sort((a, b)=>a.pageNumber - b.pageNumber);\n        chapters.push({\n            chapterNumber,\n            pages: pageArray,\n            totalPages: pageArray.length\n        });\n    });\n    return chapters.sort((a, b)=>a.chapterNumber - b.chapterNumber);\n}\n/**\r\n * API endpoint helpers for future integration\r\n */ const API_ENDPOINTS = {\n    GET_PAGE_AUDIO: (chapterNumber, pageNumber)=>\"/api/chapters/\".concat(chapterNumber, \"/pages/\").concat(pageNumber, \"/audio\"),\n    GET_CHAPTER_AUDIO: (chapterNumber)=>\"/api/chapters/\".concat(chapterNumber, \"/audio\"),\n    GET_TRANSCRIPT: (chapterNumber, pageNumber)=>\"/api/chapters/\".concat(chapterNumber, \"/pages/\").concat(pageNumber, \"/transcript\"),\n    UPLOAD_PAGE_AUDIO: (chapterNumber, pageNumber)=>\"/api/chapters/\".concat(chapterNumber, \"/pages/\").concat(pageNumber, \"/audio/upload\")\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3V0aWxzL3BhZ2VBdWRpb01hbmFnZXIudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUEsMkNBQTJDO0FBeUIzQzs7OztDQUlDLEdBQ00sU0FBU0EsbUJBQW1CQyxRQUFnQjtJQUNqRCxNQUFNQyxRQUFRRCxTQUFTQyxLQUFLLENBQUM7SUFDN0IsSUFBSSxDQUFDQSxPQUFPLE9BQU87SUFFbkIsT0FBTztRQUNMQyxlQUFlQyxTQUFTRixLQUFLLENBQUMsRUFBRSxFQUFFO1FBQ2xDRyxZQUFZRCxTQUFTRixLQUFLLENBQUMsRUFBRSxFQUFFO0lBQ2pDO0FBQ0Y7QUFFQTs7OztDQUlDLEdBQ00sU0FBU0ksd0JBQXdCTCxRQUFnQjtJQUN0RCxNQUFNQyxRQUFRRCxTQUFTQyxLQUFLLENBQUM7SUFDN0IsSUFBSSxDQUFDQSxPQUFPLE9BQU87SUFFbkIsT0FBTztRQUNMQyxlQUFlQyxTQUFTRixLQUFLLENBQUMsRUFBRSxFQUFFO1FBQ2xDRyxZQUFZRCxTQUFTRixLQUFLLENBQUMsRUFBRSxFQUFFO0lBQ2pDO0FBQ0Y7QUFFQTs7Q0FFQyxHQUNNLFNBQVNLLHVCQUNkQyxVQUFvQixFQUNwQkMsZUFBeUI7UUFDekJDLFVBQUFBLGlFQUFrQjtJQUVsQiwrRkFBK0Y7SUFDL0YsTUFBTUMsY0FBYyxDQUFDQyxNQUFjWDtRQUNqQyxJQUFJLENBQUNXLFFBQVFBLFNBQVMsS0FBSztZQUN6QixPQUFPLElBQWEsT0FBVFg7UUFDYjtRQUNBLE1BQU1ZLFVBQVVELEtBQUtFLFFBQVEsQ0FBQyxPQUFPRixLQUFLRyxLQUFLLENBQUMsR0FBRyxDQUFDLEtBQUtIO1FBQ3pELE9BQU8sR0FBY1gsT0FBWFksU0FBUSxLQUFZLE9BQVRaO0lBQ3ZCO0lBQ0EsTUFBTWUsY0FBYyxJQUFJQztJQUV4QixzQkFBc0I7SUFDdEJULFdBQVdVLE9BQU8sQ0FBQ2pCLENBQUFBO1FBQ2pCLE1BQU1rQixTQUFTbkIsbUJBQW1CQztRQUNsQyxJQUFJLENBQUNr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QkFBK0IsT0FBZEEsZUFBYztJQUNqQ3dGLGdCQUFnQixDQUFDeEYsZUFBdUJFLGFBQ3RDLGlCQUF3Q0EsT0FBdkJGLGVBQWMsV0FBb0IsT0FBWEUsWUFBVztJQUNyRHVGLG1CQUFtQixDQUFDekYsZUFBdUJFLGFBQ3pDLGlCQUF3Q0EsT0FBdkJGLGVBQWMsV0FBb0IsT0FBWEUsWUFBVztBQUN2RCxFQUFXIiwic291cmNlcyI6WyJDOlxcVXNlcnNcXGJyYWR5XFxEZXNrdG9wXFxQb3J0Zm9saW9cXGhhY2stdHgtbWFuZ2EtbmFycmF0aW9uXFxmcm9udGVuZFxcdXRpbHNcXHBhZ2VBdWRpb01hbmFnZXIudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gRmlsZTogZnJvbnRlbmQvdXRpbHMvcGFnZUF1ZGlvTWFuYWdlci50c1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBQYWdlQXVkaW9EYXRhIHtcclxuICBwYWdlTnVtYmVyOiBudW1iZXI7XHJcbiAgY2hhcHRlck51bWJlcjogbnVtYmVyO1xyXG4gIGF1ZGlvVXJsOiBzdHJpbmc7XHJcbiAgdHJhbnNjcmlwdFVybDogc3RyaW5nO1xyXG4gIHRyYW5zY3JpcHREYXRhPzogVHJhbnNjcmlwdEVudHJ5W107XHJcbiAgZHVyYXRpb24/OiBudW1iZXI7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgVHJhbnNjcmlwdEVudHJ5IHtcclxuICBpZDogc3RyaW5nO1xyXG4gIHRpbWVzdGFtcDogbnVtYmVyO1xyXG4gIHNwZWFrZXI6IHN0cmluZztcclxuICB0ZXh0OiBzdHJpbmc7XHJcbiAgaXNBY3RpdmU/OiBib29sZWFuO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIENoYXB0ZXJBdWRpb0RhdGEge1xyXG4gIGNoYXB0ZXJOdW1iZXI6IG51bWJlcjtcclxuICBwYWdlczogUGFnZUF1ZGlvRGF0YVtdO1xyXG4gIHRvdGFsUGFnZXM6IG51bWJlcjtcclxufVxyXG5cclxuLyoqXHJcbiAqIFBhcnNlcyBmaWxlbmFtZSB0byBleHRyYWN0IGNoYXB0ZXIgYW5kIHBhZ2UgaW5mb3JtYXRpb25cclxuICogRXhwZWN0ZWQgZm9ybWF0OiBjaHtjaGFwdGVyfV9wYWdle3BhZ2V9X2RpYWxvZ3VlX3t0aW1lc3RhbXB9Lm1wM1xyXG4gKiBFeGFtcGxlOiBjaDAxX3BhZ2UwMV9kaWFsb2d1ZV8yMDI1MTAxOF8yMjA3MTcubXAzXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VBdWRpb0ZpbGVuYW1lKGZpbGVuYW1lOiBzdHJpbmcpOiB7IGNoYXB0ZXJOdW1iZXI6IG51bWJlcjsgcGFnZU51bWJlcjogbnVtYmVyIH0gfCBudWxsIHtcclxuICBjb25zdCBtYXRjaCA9IGZpbGVuYW1lLm1hdGNoKC9jaChcXGQrKV9wYWdlKFxcZCspX2RpYWxvZ3VlLyk7XHJcbiAgaWYgKCFtYXRjaCkgcmV0dXJuIG51bGw7XHJcbiAgXHJcbiAgcmV0dXJuIHtcclxuICAgIGNoYXB0ZXJOdW1iZXI6IHBhcnNlSW50KG1hdGNoWzFdLCAxMCksXHJcbiAgICBwYWdlTnVtYmVyOiBwYXJzZUludChtYXRjaFsyXSwgMTApXHJcbiAgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFBhcnNlcyB0cmFuc2NyaXB0IGZpbGVuYW1lIHRvIGV4dHJhY3QgY2hhcHRlciBhbmQgcGFnZSBpbmZvcm1hdGlvblxyXG4gKiBFeHBlY3RlZCBmb3JtYXQ6IGNoe2NoYXB0ZXJ9X3BhZ2V7cGFnZX1fdHJhbnNjcmlwdF97dGltZXN0YW1wfS50eHRcclxuICogRXhhbXBsZTogY2gwMV9wYWdlMDFfdHJhbnNjcmlwdF8yMDI1MTAxOF8yMjA3MTcudHh0XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VUcmFuc2NyaXB0RmlsZW5hbWUoZmlsZW5hbWU6IHN0cmluZyk6IHsgY2hhcHRlck51bWJlcjogbnVtYmVyOyBwYWdlTnVtYmVyOiBudW1iZXIgfSB8IG51bGwge1xyXG4gIGNvbnN0IG1hdGNoID0gZmlsZW5hbWUubWF0Y2goL2NoKFxcZCspX3BhZ2UoXFxkKylfdHJhbnNjcmlwdC8pO1xyXG4gIGlmICghbWF0Y2gpIHJldHVybiBudWxsO1xyXG4gIFxyXG4gIHJldHVybiB7XHJcbiAgICBjaGFwdGVyTnVtYmVyOiBwYXJzZUludChtYXRjaFsxXSwgMTApLFxyXG4gICAgcGFnZU51bWJlcjogcGFyc2VJbnQobWF0Y2hbMl0sIDEwKVxyXG4gIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBHcm91cHMgYXVkaW8gYW5kIHRyYW5zY3JpcHQgZmlsZXMgYnkgY2hhcHRlciBhbmQgcGFnZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIG9yZ2FuaXplUGFnZUF1ZGlvRmlsZXMoXHJcbiAgYXVkaW9GaWxlczogc3RyaW5nW10sXHJcbiAgdHJhbnNjcmlwdEZpbGVzOiBzdHJpbmdbXSxcclxuICBiYXNlVXJsOiBzdHJpbmcgPSAnL2Fzc2V0cydcclxuKTogQ2hhcHRlckF1ZGlvRGF0YVtdIHtcclxuICAvLyBFbnN1cmUgd2Ugam9pbiBiYXNlVXJsIGFuZCBmaWxlbmFtZXMgd2l0aG91dCBwcm9kdWNpbmcgcHJvdG9jb2wtcmVsYXRpdmUgVVJMcyAoZS5nLiwgLy9maWxlKVxyXG4gIGNvbnN0IGpvaW5VcmxQYXRoID0gKHJvb3Q6IHN0cmluZywgZmlsZW5hbWU6IHN0cmluZyk6IHN0cmluZyA9PiB7XHJcbiAgICBpZiAoIXJvb3QgfHwgcm9vdCA9PT0gJy8nKSB7XHJcbiAgICAgIHJldHVybiBgLyR7ZmlsZW5hbWV9YDtcclxuICAgIH1cclxuICAgIGNvbnN0IHRyaW1tZWQgPSByb290LmVuZHNXaXRoKCcvJykgPyByb290LnNsaWNlKDAsIC0xKSA6IHJvb3Q7XHJcbiAgICByZXR1cm4gYCR7dHJpbW1lZH0vJHtmaWxlbmFtZX1gO1xyXG4gIH07XHJcbiAgY29uc3QgY2hhcHRlcnNNYXAgPSBuZXcgTWFwPG51bWJlciwgTWFwPG51bWJlciwgUGFnZUF1ZGlvRGF0YT4+KCk7XHJcbiAgXHJcbiAgLy8gUHJvY2VzcyBhdWRpbyBmaWxlc1xyXG4gIGF1ZGlvRmlsZXMuZm9yRWFjaChmaWxlbmFtZSA9PiB7XHJcbiAgICBjb25zdCBwYXJzZWQgPSBwYXJzZUF1ZGlvRmlsZW5hbWUoZmlsZW5hbWUpO1xyXG4gICAgaWYgKCFwYXJzZWQpIHJldHVybjtcclxuICAgIFxyXG4gICAgY29uc3QgeyBjaGFwdGVyTnVtYmVyLCBwYWdlTnVtYmVyIH0gPSBwYXJzZWQ7XHJcbiAgICBcclxuICAgIGlmICghY2hhcHRlcnNNYXAuaGFzKGNoYXB0ZXJOdW1iZXIpKSB7XHJcbiAgICAgIGNoYXB0ZXJzTWFwLnNldChjaGFwdGVyTnVtYmVyLCBuZXcgTWFwKCkpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBjb25zdCBjaGFwdGVyUGFnZXMgPSBjaGFwdGVyc01hcC5nZXQoY2hhcHRlck51bWJlcikhO1xyXG4gICAgaWYgKCFjaGFwdGVyUGFnZXMuaGFzKHBhZ2VOdW1iZXIpKSB7XHJcbiAgICAgIGNoYXB0ZXJQYWdlcy5zZXQocGFnZU51bWJlciwge1xyXG4gICAgICAgIHBhZ2VOdW1iZXIsXHJcbiAgICAgICAgY2hhcHRlck51bWJlcixcclxuICAgICAgICBhdWRpb1VybDogJycsXHJcbiAgICAgICAgdHJhbnNjcmlwdFVybDogJydcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGNoYXB0ZXJQYWdlcy5nZXQocGFnZU51bWJlcikhLmF1ZGlvVXJsID0gam9pblVybFBhdGgoYmFzZVVybCwgZmlsZW5hbWUpO1xyXG4gIH0pO1xyXG4gIFxyXG4gIC8vIFByb2Nlc3MgdHJhbnNjcmlwdCBmaWxlc1xyXG4gIHRyYW5zY3JpcHRGaWxlcy5mb3JFYWNoKGZpbGVuYW1lID0+IHtcclxuICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlVHJhbnNjcmlwdEZpbGVuYW1lKGZpbGVuYW1lKTtcclxuICAgIGlmICghcGFyc2VkKSByZXR1cm47XHJcbiAgICBcclxuICAgIGNvbnN0IHsgY2hhcHRlck51bWJlciwgcGFnZU51bWJlciB9ID0gcGFyc2VkO1xyXG4gICAgXHJcbiAgICBpZiAoIWNoYXB0ZXJzTWFwLmhhcyhjaGFwdGVyTnVtYmVyKSkge1xyXG4gICAgICBjaGFwdGVyc01hcC5zZXQoY2hhcHRlck51bWJlciwgbmV3IE1hcCgpKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgY29uc3QgY2hhcHRlclBhZ2VzID0gY2hhcHRlcnNNYXAuZ2V0KGNoYXB0ZXJOdW1iZXIpITtcclxuICAgIGlmICghY2hhcHRlclBhZ2VzLmhhcyhwYWdlTnVtYmVyKSkge1xyXG4gICAgICBjaGFwdGVyUGFnZXMuc2V0KHBhZ2VOdW1iZXIsIHtcclxuICAgICAgICBwYWdlTnVtYmVyLFxyXG4gICAgICAgIGNoYXB0ZXJOdW1iZXIsXHJcbiAgICAgICAgYXVkaW9Vcmw6ICcnLFxyXG4gICAgICAgIHRyYW5zY3JpcHRVcmw6ICcnXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBjaGFwdGVyUGFnZXMuZ2V0KHBhZ2VOdW1iZXIpIS50cmFuc2NyaXB0VXJsID0gam9pblVybFBhdGgoYmFzZVVybCwgZmlsZW5hbWUpO1xyXG4gIH0pO1xyXG4gIFxyXG4gIC8vIENvbnZlcnQgdG8gYXJyYXkgZm9ybWF0XHJcbiAgY29uc3QgY2hhcHRlcnM6IENoYXB0ZXJBdWRpb0RhdGFbXSA9IFtdO1xyXG4gIGNoYXB0ZXJzTWFwLmZvckVhY2goKHBhZ2VzLCBjaGFwdGVyTnVtYmVyKSA9PiB7XHJcbiAgICBjb25zdCBwYWdlQXJyYXkgPSBBcnJheS5mcm9tKHBhZ2VzLnZhbHVlcygpKS5zb3J0KChhLCBiKSA9PiBhLnBhZ2VOdW1iZXIgLSBiLnBhZ2VOdW1iZXIpO1xyXG4gICAgY2hhcHRlcnMucHVzaCh7XHJcbiAgICAgIGNoYXB0ZXJOdW1iZXIsXHJcbiAgICAgIHBhZ2VzOiBwYWdlQXJyYXksXHJcbiAgICAgIHRvdGFsUGFnZXM6IHBhZ2VBcnJheS5sZW5ndGhcclxuICAgIH0pO1xyXG4gIH0pO1xyXG4gIFxyXG4gIGNvbnN0IHJlc3VsdCA9IGNoYXB0ZXJzLnNvcnQoKGEsIGIpID0+IGEuY2hhcHRlck51bWJlciAtIGIuY2hhcHRlck51bWJlcik7XHJcbiAgcmV0dXJuIHJlc3VsdDtcclxufVxyXG5cclxuLyoqXHJcbiAqIExvYWRzIHRyYW5zY3JpcHQgZGF0YSBmcm9tIFVSTFxyXG4gKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGxvYWRUcmFuc2NyaXB0RGF0YSh0cmFuc2NyaXB0VXJsOiBzdHJpbmcpOiBQcm9taXNlPFRyYW5zY3JpcHRFbnRyeVtdPiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2godHJhbnNjcmlwdFVybCk7XHJcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGxvYWQgdHJhbnNjcmlwdDogJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBjb25zdCBjb250ZW50ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpO1xyXG4gICAgY29uc3QgcGFyc2VkID0gcGFyc2VUcmFuc2NyaXB0Q29udGVudChjb250ZW50KTtcclxuICAgIHJldHVybiBwYXJzZWQ7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGxvYWRpbmcgdHJhbnNjcmlwdDonLCBlcnJvcik7XHJcbiAgICByZXR1cm4gW107XHJcbiAgfVxyXG59XHJcblxyXG4vKipcclxuICogUGFyc2VzIHRyYW5zY3JpcHQgY29udGVudCBpbnRvIHN0cnVjdHVyZWQgZW50cmllc1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlVHJhbnNjcmlwdENvbnRlbnQoY29udGVudDogc3RyaW5nKTogVHJhbnNjcmlwdEVudHJ5W10ge1xyXG4gIC8vIFJlbW92ZSBwb3RlbnRpYWwgVVRGLTggQk9NIGFuZCBub3JtYWxpemUgbGluZSBlbmRpbmdzXHJcbiAgY29uc3Qgc2FuaXRpemVkID0gY29udGVudC5yZXBsYWNlKC9eXFx1RkVGRi8sICcnKTtcclxuICBjb25zdCBsaW5lcyA9IHNhbml0aXplZC5zcGxpdCgvXFxyP1xcbi8pO1xyXG4gIGNvbnN0IGVudHJpZXM6IFRyYW5zY3JpcHRFbnRyeVtdID0gW107XHJcbiAgXHJcbiAgbGluZXMuZm9yRWFjaCgobGluZSwgaW5kZXgpID0+IHtcclxuICAgIGNvbnN0IHRyaW1tZWQgPSBsaW5lLnRyaW0oKTtcclxuICAgIGlmICghdHJpbW1lZCkgcmV0dXJuO1xyXG4gICAgLy8gQWxsb3cgbGVhZGluZyBzcGFjZXMgYmVmb3JlIHRpbWVzdGFtcCBhbmQgdHJhaWxpbmcgc3BhY2VzIGF0IGVuZFxyXG4gICAgY29uc3QgbWF0Y2ggPSB0cmltbWVkLm1hdGNoKC9eXFxzKihcXGR7Mn06XFxkezJ9KVxccysoLis/KTpcXHMrKC4rKVxccyokLyk7XHJcbiAgICBpZiAobWF0Y2gpIHtcclxuICAgICAgY29uc3QgWywgdGltZVN0ciwgc3BlYWtlciwgdGV4dF0gPSBtYXRjaDtcclxuICAgICAgY29uc3QgW21pbnV0ZXMsIHNlY29uZHNdID0gdGltZVN0ci5zcGxpdCgnOicpLm1hcChOdW1iZXIpO1xyXG4gICAgICBjb25zdCB0aW1lc3RhbXAgPSBtaW51dGVzICogNjAgKyBzZWNvbmRzO1xyXG4gICAgICBcclxuICAgICAgZW50cmllcy5wdXNoKHtcclxuICAgICAgICBpZDogYGVudHJ5LSR7aW5kZXh9YCxcclxuICAgICAgICB0aW1lc3RhbXAsXHJcbiAgICAgICAgc3BlYWtlcjogc3BlYWtlci50cmltKCksXHJcbiAgICAgICAgdGV4dDogdGV4dC50cmltKCksXHJcbiAgICAgICAgaXNBY3RpdmU6IGZhbHNlXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH0pO1xyXG4gIFxyXG4gIHJldHVybiBlbnRyaWVzO1xyXG59XHJcblxyXG4vKipcclxuICogRmluZHMgdGhlIGFjdGl2ZSB0cmFuc2NyaXB0IGVudHJ5IGJhc2VkIG9uIGN1cnJlbnQgdGltZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRBY3RpdmVUcmFuc2NyaXB0RW50cnkoXHJcbiAgZW50cmllczogVHJhbnNjcmlwdEVudHJ5W10sIFxyXG4gIGN1cnJlbnRUaW1lOiBudW1iZXJcclxuKTogVHJhbnNjcmlwdEVudHJ5IHwgbnVsbCB7XHJcbiAgbGV0IGFjdGl2ZUVudHJ5OiBUcmFuc2NyaXB0RW50cnkgfCBudWxsID0gbnVsbDtcclxuICBcclxuICBmb3IgKGxldCBpID0gMDsgaSA8IGVudHJpZXMubGVuZ3RoOyBpKyspIHtcclxuICAgIGNvbnN0IGVudHJ5ID0gZW50cmllc1tpXTtcclxuICAgIGNvbnN0IG5leHRFbnRyeSA9IGVudHJpZXNbaSArIDFdO1xyXG4gICAgXHJcbiAgICBpZiAoY3VycmVudFRpbWUgPj0gZW50cnkudGltZXN0YW1wICYmICghbmV4dEVudHJ5IHx8IGN1cnJlbnRUaW1lIDwgbmV4dEVudHJ5LnRpbWVzdGFtcCkpIHtcclxuICAgICAgYWN0aXZlRW50cnkgPSBlbnRyeTtcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgfVxyXG4gIFxyXG4gIHJldHVybiBhY3RpdmVFbnRyeTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFVwZGF0ZXMgYWN0aXZlIHN0YXRlIGZvciB0cmFuc2NyaXB0IGVudHJpZXNcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVUcmFuc2NyaXB0QWN0aXZlU3RhdGUoXHJcbiAgZW50cmllczogVHJhbnNjcmlwdEVudHJ5W10sIFxyXG4gIGN1cnJlbnRUaW1lOiBudW1iZXJcclxuKTogVHJhbnNjcmlwdEVudHJ5W10ge1xyXG4gIHJldHVybiBlbnRyaWVzLm1hcChlbnRyeSA9PiAoe1xyXG4gICAgLi4uZW50cnksXHJcbiAgICBpc0FjdGl2ZTogZW50cnkudGltZXN0YW1wIDw9IGN1cnJlbnRUaW1lICYmIFxyXG4gICAgICAgICAgICAgIChlbnRyaWVzLmZpbmQoZSA9PiBlLnRpbWVzdGFtcCA+IGVudHJ5LnRpbWVzdGFtcCk/LnRpbWVzdGFtcCB8fCBJbmZpbml0eSkgPiBjdXJyZW50VGltZVxyXG4gIH0pKTtcclxufVxyXG5cclxuLy8gQVBJIEludGVncmF0aW9uIEhlbHBlcnMgKGZvciBmdXR1cmUgU3VwYWJhc2UgaW50ZWdyYXRpb24pXHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFN1cGFiYXNlUGFnZUF1ZGlvRGF0YSB7XHJcbiAgaWQ6IHN0cmluZztcclxuICBjaGFwdGVyX251bWJlcjogbnVtYmVyO1xyXG4gIHBhZ2VfbnVtYmVyOiBudW1iZXI7XHJcbiAgYXVkaW9fdXJsOiBzdHJpbmc7XHJcbiAgdHJhbnNjcmlwdF91cmw6IHN0cmluZztcclxuICB0cmFuc2NyaXB0X2NvbnRlbnQ/OiBzdHJpbmc7XHJcbiAgZHVyYXRpb24/OiBudW1iZXI7XHJcbiAgY3JlYXRlZF9hdDogc3RyaW5nO1xyXG4gIHVwZGF0ZWRfYXQ6IHN0cmluZztcclxufVxyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIFN1cGFiYXNlIGRhdGEgdG8gbG9jYWwgZm9ybWF0XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY29udmVydFN1cGFiYXNlVG9Mb2NhbChzdXBhYmFzZURhdGE6IFN1cGFiYXNlUGFnZUF1ZGlvRGF0YVtdKTogQ2hhcHRlckF1ZGlvRGF0YVtdIHtcclxuICBjb25zdCBjaGFwdGVyc01hcCA9IG5ldyBNYXA8bnVtYmVyLCBNYXA8bnVtYmVyLCBQYWdlQXVkaW9EYXRhPj4oKTtcclxuICBcclxuICBzdXBhYmFzZURhdGEuZm9yRWFjaChpdGVtID0+IHtcclxuICAgIGlmICghY2hhcHRlcnNNYXAuaGFzKGl0ZW0uY2hhcHRlcl9udW1iZXIpKSB7XHJcbiAgICAgIGNoYXB0ZXJzTWFwLnNldChpdGVtLmNoYXB0ZXJfbnVtYmVyLCBuZXcgTWFwKCkpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBjb25zdCBjaGFwdGVyUGFnZXMgPSBjaGFwdGVyc01hcC5nZXQoaXRlbS5jaGFwdGVyX251bWJlcikhO1xyXG4gICAgY2hhcHRlclBhZ2VzLnNldChpdGVtLnBhZ2VfbnVtYmVyLCB7XHJcbiAgICAgIHBhZ2VOdW1iZXI6IGl0ZW0ucGFnZV9udW1iZXIsXHJcbiAgICAgIGNoYXB0ZXJOdW1iZXI6IGl0ZW0uY2hhcHRlcl9udW1iZXIsXHJcbiAgICAgIGF1ZGlvVXJsOiBpdGVtLmF1ZGlvX3VybCxcclxuICAgICAgdHJhbnNjcmlwdFVybDogaXRlbS50cmFuc2NyaXB0X3VybCxcclxuICAgICAgdHJhbnNjcmlwdERhdGE6IGl0ZW0udHJhbnNjcmlwdF9jb250ZW50ID8gcGFyc2VUcmFuc2NyaXB0Q29udGVudChpdGVtLnRyYW5zY3JpcHRfY29udGVudCkgOiB1bmRlZmluZWQsXHJcbiAgICAgIGR1cmF0aW9uOiBpdGVtLmR1cmF0aW9uXHJcbiAgICB9KTtcclxuICB9KTtcclxuICBcclxuICBjb25zdCBjaGFwdGVyczogQ2hhcHRlckF1ZGlvRGF0YVtdID0gW107XHJcbiAgY2hhcHRlcnNNYXAuZm9yRWFjaCgocGFnZXMsIGNoYXB0ZXJOdW1iZXIpID0+IHtcclxuICAgIGNvbnN0IHBhZ2VBcnJheSA9IEFycmF5LmZyb20ocGFnZXMudmFsdWVzKCkpLnNvcnQoKGEsIGIpID0+IGEucGFnZU51bWJlciAtIGIucGFnZU51bWJlcik7XHJcbiAgICBjaGFwdGVycy5wdXNoKHtcclxuICAgICAgY2hhcHRlck51bWJlcixcclxuICAgICAgcGFnZXM6IHBhZ2VBcnJheSxcclxuICAgICAgdG90YWxQYWdlczogcGFnZUFycmF5Lmxlbmd0aFxyXG4gICAgfSk7XHJcbiAgfSk7XHJcbiAgXHJcbiAgcmV0dXJuIGNoYXB0ZXJzLnNvcnQoKGEsIGIpID0+IGEuY2hhcHRlck51bWJlciAtIGIuY2hhcHRlck51bWJlcik7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBUEkgZW5kcG9pbnQgaGVscGVycyBmb3IgZnV0dXJlIGludGVncmF0aW9uXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgQVBJX0VORFBPSU5UUyA9IHtcclxuICBHRVRfUEFHRV9BVURJTzogKGNoYXB0ZXJOdW1iZXI6IG51bWJlciwgcGFnZU51bWJlcjogbnVtYmVyKSA9PiBcclxuICAgIGAvYXBpL2NoYXB0ZXJzLyR7Y2hhcHRlck51bWJlcn0vcGFnZXMvJHtwYWdlTnVtYmVyfS9hdWRpb2AsXHJcbiAgR0VUX0NIQVBURVJfQVVESU86IChjaGFwdGVyTnVtYmVyOiBudW1iZXIpID0+IFxyXG4gICAgYC9hcGkvY2hhcHRlcnMvJHtjaGFwdGVyTnVtYmVyfS9hdWRpb2AsXHJcbiAgR0VUX1RSQU5TQ1JJUFQ6IChjaGFwdGVyTnVtYmVyOiBudW1iZXIsIHBhZ2VOdW1iZXI6IG51bWJlcikgPT4gXHJcbiAgICBgL2FwaS9jaGFwdGVycy8ke2NoYXB0ZXJOdW1iZXJ9L3BhZ2VzLyR7cGFnZU51bWJlcn0vdHJhbnNjcmlwdGAsXHJcbiAgVVBMT0FEX1BBR0VfQVVESU86IChjaGFwdGVyTnVtYmVyOiBudW1iZXIsIHBhZ2VOdW1iZXI6IG51bWJlcikgPT4gXHJcbiAgICBgL2FwaS9jaGFwdGVycy8ke2NoYXB0ZXJOdW1iZXJ9L3BhZ2VzLyR7cGFnZU51bWJlcn0vYXVkaW8vdXBsb2FkYFxyXG59IGFzIGNvbnN0O1xyXG4iXSwibmFtZXMiOlsicGFyc2VBdWRpb0ZpbGVuYW1lIiwiZmlsZW5hbWUiLCJtYXRjaCIsImNoYXB0ZXJOdW1iZXIiLCJwYXJzZUludCIsInBhZ2VOdW1iZXIiLCJwYXJzZVRyYW5zY3JpcHRGaWxlbmFtZSIsIm9yZ2FuaXplUGFnZUF1ZGlvRmlsZXMiLCJhdWRpb0ZpbGVzIiwidHJhbnNjcmlwdEZpbGVzIiwiYmFzZVVybCIsImpvaW5VcmxQYXRoIiwicm9vdCIsInRyaW1tZWQiLCJlbmRzV2l0aCIsInNsaWNlIiwiY2hhcHRlcnNNYXAiLCJNYXAiLCJmb3JFYWNoIiwicGFyc2VkIiwiaGFzIiwic2V0IiwiY2hhcHRlclBhZ2VzIiwiZ2V0IiwiYXVkaW9VcmwiLCJ0cmFuc2NyaXB0VXJsIiwiY2hhcHRlcnMiLCJwYWdlcyIsInBhZ2VBcnJheSIsIkFycmF5IiwiZnJvbSIsInZhbHVlcyIsInNvcnQiLCJhIiwiYiIsInB1c2giLCJ0b3RhbFBhZ2VzIiwibGVuZ3RoIiwicmVzdWx0IiwibG9hZFRyYW5zY3JpcHREYXRhIiwicmVzcG9uc2UiLCJmZXRjaCIsIm9rIiwiRXJyb3IiLCJzdGF0dXNUZXh0IiwiY29udGVudCIsInRleHQiLCJwYXJzZVRyYW5zY3JpcHRDb250ZW50IiwiZXJyb3IiLCJjb25zb2xlIiwic2FuaXRpemVkIiwicmVwbGFjZSIsImxpbmVzIiwic3BsaXQiLCJlbnRyaWVzIiwibGluZSIsImluZGV4IiwidHJpbSIsInRpbWVTdHIiLCJzcGVha2VyIiwibWludXRlcyIsInNlY29uZHMiLCJtYXAiLCJOdW1iZXIiLCJ0aW1lc3RhbXAiLCJpZCIsImlzQWN0aXZlIiwiZmluZEFjdGl2ZVRyYW5zY3JpcHRFbnRyeSIsImN1cnJlbnRUaW1lIiwiYWN0aXZlRW50cnkiLCJpIiwiZW50cnkiLCJuZXh0RW50cnkiLCJ1cGRhdGVUcmFuc2NyaXB0QWN0aXZlU3RhdGUiLCJmaW5kIiwiZSIsIkluZmluaXR5IiwiY29udmVydFN1cGFiYXNlVG9Mb2NhbCIsInN1cGFiYXNlRGF0YSIsIml0ZW0iLCJjaGFwdGVyX251bWJlciIsInBhZ2VfbnVtYmVyIiwiYXVkaW9fdXJsIiwidHJhbnNjcmlwdF91cmwiLCJ0cmFuc2NyaXB0RGF0YSIsInRyYW5zY3JpcHRfY29udGVudCIsInVuZGVmaW5lZCIsImR1cmF0aW9uIiwiQVBJX0VORFBPSU5UUyIsIkdFVF9QQUdFX0FVRElPIiwiR0VUX0NIQVBURVJfQVVESU8iLCJHRVRfVFJBTlNDUklQVCIsIlVQTE9BRF9QQUdFX0FVRElPIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./utils/pageAudioManager.ts\n"));

/***/ })

});