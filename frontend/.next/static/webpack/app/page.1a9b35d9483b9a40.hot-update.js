"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./utils/pageAudioManager.ts":
/*!***********************************!*\
  !*** ./utils/pageAudioManager.ts ***!
  \***********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   API_ENDPOINTS: () => (/* binding */ API_ENDPOINTS),\n/* harmony export */   convertSupabaseToLocal: () => (/* binding */ convertSupabaseToLocal),\n/* harmony export */   findActiveTranscriptEntry: () => (/* binding */ findActiveTranscriptEntry),\n/* harmony export */   loadTranscriptData: () => (/* binding */ loadTranscriptData),\n/* harmony export */   organizePageAudioFiles: () => (/* binding */ organizePageAudioFiles),\n/* harmony export */   parseAudioFilename: () => (/* binding */ parseAudioFilename),\n/* harmony export */   parseTranscriptContent: () => (/* binding */ parseTranscriptContent),\n/* harmony export */   parseTranscriptFilename: () => (/* binding */ parseTranscriptFilename),\n/* harmony export */   updateTranscriptActiveState: () => (/* binding */ updateTranscriptActiveState)\n/* harmony export */ });\n// File: frontend/utils/pageAudioManager.ts\n/**\r\n * Parses filename to extract chapter and page information\r\n * Expected format: ch{chapter}_page{page}_dialogue_{timestamp}.mp3\r\n * Example: ch01_page01_dialogue_20251018_220717.mp3\r\n */ function parseAudioFilename(filename) {\n    const match = filename.match(/ch(\\d+)_page(\\d+)_dialogue/);\n    if (!match) return null;\n    return {\n        chapterNumber: parseInt(match[1], 10),\n        pageNumber: parseInt(match[2], 10)\n    };\n}\n/**\r\n * Parses transcript filename to extract chapter and page information\r\n * Expected format: ch{chapter}_page{page}_transcript_{timestamp}.txt\r\n * Example: ch01_page01_transcript_20251018_220717.txt\r\n */ function parseTranscriptFilename(filename) {\n    const match = filename.match(/ch(\\d+)_page(\\d+)_transcript/);\n    if (!match) return null;\n    return {\n        chapterNumber: parseInt(match[1], 10),\n        pageNumber: parseInt(match[2], 10)\n    };\n}\n/**\r\n * Groups audio and transcript files by chapter and page\r\n */ function organizePageAudioFiles(audioFiles, transcriptFiles) {\n    let baseUrl = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : '/assets';\n    // Ensure we join baseUrl and filenames without producing protocol-relative URLs (e.g., //file)\n    const joinUrlPath = (root, filename)=>{\n        if (!root || root === '/') {\n            return \"/\".concat(filename);\n        }\n        const trimmed = root.endsWith('/') ? root.slice(0, -1) : root;\n        return \"\".concat(trimmed, \"/\").concat(filename);\n    };\n    const chaptersMap = new Map();\n    // Process audio files\n    audioFiles.forEach((filename)=>{\n        const parsed = parseAudioFilename(filename);\n        if (!parsed) return;\n        const { chapterNumber, pageNumber } = parsed;\n        if (!chaptersMap.has(chapterNumber)) {\n            chaptersMap.set(chapterNumber, new Map());\n        }\n        const chapterPages = chaptersMap.get(chapterNumber);\n        if (!chapterPages.has(pageNumber)) {\n            chapterPages.set(pageNumber, {\n                pageNumber,\n                chapterNumber,\n                audioUrl: '',\n                transcriptUrl: ''\n            });\n        }\n        chapterPages.get(pageNumber).audioUrl = joinUrlPath(baseUrl, filename);\n    });\n    // Process transcript files\n    transcriptFiles.forEach((filename)=>{\n        const parsed = parseTranscriptFilename(filename);\n        if (!parsed) return;\n        const { chapterNumber, pageNumber } = parsed;\n        if (!chaptersMap.has(chapterNumber)) {\n            chaptersMap.set(chapterNumber, new Map());\n        }\n        const chapterPages = chaptersMap.get(chapterNumber);\n        if (!chapterPages.has(pageNumber)) {\n            chapterPages.set(pageNumber, {\n                pageNumber,\n                chapterNumber,\n                audioUrl: '',\n                transcriptUrl: ''\n            });\n        }\n        chapterPages.get(pageNumber).transcriptUrl = joinUrlPath(baseUrl, filename);\n    });\n    // Convert to array format\n    const chapters = [];\n    chaptersMap.forEach((pages, chapterNumber)=>{\n        const pageArray = Array.from(pages.values()).sort((a, b)=>a.pageNumber - b.pageNumber);\n        chapters.push({\n            chapterNumber,\n            pages: pageArray,\n            totalPages: pageArray.length\n        });\n    });\n    const result = chapters.sort((a, b)=>a.chapterNumber - b.chapterNumber);\n    return result;\n}\n/**\r\n * Loads transcript data from URL\r\n */ async function loadTranscriptData(transcriptUrl) {\n    try {\n        const response = await fetch(transcriptUrl);\n        if (!response.ok) {\n            throw new Error(\"Failed to load transcript: \".concat(response.statusText));\n        }\n        const content = await response.text();\n        const parsed = parseTranscriptContent(content);\n        return parsed;\n    } catch (error) {\n        console.error('Error loading transcript:', error);\n        return [];\n    }\n}\n/**\r\n * Parses transcript content into structured entries\r\n */ function parseTranscriptContent(content) {\n    // Remove potential UTF-8 BOM to ensure the first timestamp parses correctly\n    const sanitized = content.replace(/^\\uFEFF/, '').trim();\n    const lines = sanitized.split('\\n');\n    const entries = [];\n    lines.forEach((line, index)=>{\n        const match = line.match(/^(\\d{2}:\\d{2})\\s+(.+?):\\s+(.+)$/);\n        if (match) {\n            const [, timeStr, speaker, text] = match;\n            const [minutes, seconds] = timeStr.split(':').map(Number);\n            const timestamp = minutes * 60 + seconds;\n            entries.push({\n                id: \"entry-\".concat(index),\n                timestamp,\n                speaker: speaker.trim(),\n                text: text.trim(),\n                isActive: false\n            });\n        }\n    });\n    return entries;\n}\n/**\r\n * Finds the active transcript entry based on current time\r\n */ function findActiveTranscriptEntry(entries, currentTime) {\n    let activeEntry = null;\n    for(let i = 0; i < entries.length; i++){\n        const entry = entries[i];\n        const nextEntry = entries[i + 1];\n        if (currentTime >= entry.timestamp && (!nextEntry || currentTime < nextEntry.timestamp)) {\n            activeEntry = entry;\n            break;\n        }\n    }\n    return activeEntry;\n}\n/**\r\n * Updates active state for transcript entries\r\n */ function updateTranscriptActiveState(entries, currentTime) {\n    return entries.map((entry)=>{\n        var _entries_find;\n        return {\n            ...entry,\n            isActive: entry.timestamp <= currentTime && (((_entries_find = entries.find((e)=>e.timestamp > entry.timestamp)) === null || _entries_find === void 0 ? void 0 : _entries_find.timestamp) || Infinity) > currentTime\n        };\n    });\n}\n/**\r\n * Converts Supabase data to local format\r\n */ function convertSupabaseToLocal(supabaseData) {\n    const chaptersMap = new Map();\n    supabaseData.forEach((item)=>{\n        if (!chaptersMap.has(item.chapter_number)) {\n            chaptersMap.set(item.chapter_number, new Map());\n        }\n        const chapterPages = chaptersMap.get(item.chapter_number);\n        chapterPages.set(item.page_number, {\n            pageNumber: item.page_number,\n            chapterNumber: item.chapter_number,\n            audioUrl: item.audio_url,\n            transcriptUrl: item.transcript_url,\n            transcriptData: item.transcript_content ? parseTranscriptContent(item.transcript_content) : undefined,\n            duration: item.duration\n        });\n    });\n    const chapters = [];\n    chaptersMap.forEach((pages, chapterNumber)=>{\n        const pageArray = Array.from(pages.values()).sort((a, b)=>a.pageNumber - b.pageNumber);\n        chapters.push({\n            chapterNumber,\n            pages: pageArray,\n            totalPages: pageArray.length\n        });\n    });\n    return chapters.sort((a, b)=>a.chapterNumber - b.chapterNumber);\n}\n/**\r\n * API endpoint helpers for future integration\r\n */ const API_ENDPOINTS = {\n    GET_PAGE_AUDIO: (chapterNumber, pageNumber)=>\"/api/chapters/\".concat(chapterNumber, \"/pages/\").concat(pageNumber, \"/audio\"),\n    GET_CHAPTER_AUDIO: (chapterNumber)=>\"/api/chapters/\".concat(chapterNumber, \"/audio\"),\n    GET_TRANSCRIPT: (chapterNumber, pageNumber)=>\"/api/chapters/\".concat(chapterNumber, \"/pages/\").concat(pageNumber, \"/transcript\"),\n    UPLOAD_PAGE_AUDIO: (chapterNumber, pageNumber)=>\"/api/chapters/\".concat(chapterNumber, \"/pages/\").concat(pageNumber, \"/audio/upload\")\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3V0aWxzL3BhZ2VBdWRpb01hbmFnZXIudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUEsMkNBQTJDO0FBeUIzQzs7OztDQUlDLEdBQ00sU0FBU0EsbUJBQW1CQyxRQUFnQjtJQUNqRCxNQUFNQyxRQUFRRCxTQUFTQyxLQUFLLENBQUM7SUFDN0IsSUFBSSxDQUFDQSxPQUFPLE9BQU87SUFFbkIsT0FBTztRQUNMQyxlQUFlQyxTQUFTRixLQUFLLENBQUMsRUFBRSxFQUFFO1FBQ2xDRyxZQUFZRCxTQUFTRixLQUFLLENBQUMsRUFBRSxFQUFFO0lBQ2pDO0FBQ0Y7QUFFQTs7OztDQUlDLEdBQ00sU0FBU0ksd0JBQXdCTCxRQUFnQjtJQUN0RCxNQUFNQyxRQUFRRCxTQUFTQyxLQUFLLENBQUM7SUFDN0IsSUFBSSxDQUFDQSxPQUFPLE9BQU87SUFFbkIsT0FBTztRQUNMQyxlQUFlQyxTQUFTRixLQUFLLENBQUMsRUFBRSxFQUFFO1FBQ2xDRyxZQUFZRCxTQUFTRixLQUFLLENBQUMsRUFBRSxFQUFFO0lBQ2pDO0FBQ0Y7QUFFQTs7Q0FFQyxHQUNNLFNBQVNLLHVCQUNkQyxVQUFvQixFQUNwQkMsZUFBeUI7UUFDekJDLFVBQUFBLGlFQUFrQjtJQUVsQiwrRkFBK0Y7SUFDL0YsTUFBTUMsY0FBYyxDQUFDQyxNQUFjWDtRQUNqQyxJQUFJLENBQUNXLFFBQVFBLFNBQVMsS0FBSztZQUN6QixPQUFPLElBQWEsT0FBVFg7UUFDYjtRQUNBLE1BQU1ZLFVBQVVELEtBQUtFLFFBQVEsQ0FBQyxPQUFPRixLQUFLRyxLQUFLLENBQUMsR0FBRyxDQUFDLEtBQUtIO1FBQ3pELE9BQU8sR0FBY1gsT0FBWFksU0FBUSxLQUFZLE9BQVRaO0lBQ3ZCO0lBQ0EsTUFBTWUsY0FBYyxJQUFJQztJQUV4QixzQkFBc0I7SUFDdEJULFdBQVdVLE9BQU8sQ0FBQ2pCLENBQUFBO1FBQ2pCLE1BQU1rQixTQUFTbkIsbUJBQW1CQztRQUNsQyxJQUFJLENBQUNrQixRQUFRO1FBRWIsTUFBTSxFQUFFaEIsYUFBYSxFQUFFRSxVQUFVLEVBQUUsR0FBR2M7UUFFdEMsSUFBSSxDQUFDSCxZQUFZSSxHQUFHLENBQUNqQixnQkFBZ0I7WUFDbkNhLFlBQVlLLEdBQUcsQ0FBQ2xCLGVBQWUsSUFBSWM7UUFDckM7UUFFQSxNQUFNSyxlQUFlTixZQUFZTyxHQUFHLENBQUNwQjtRQUNyQyxJQUFJLENBQUNtQixhQUFhRixHQUFHLENBQUNmLGFBQWE7WUFDakNpQixhQUFhRCxHQUFHLENBQUNoQixZQUFZO2dCQUMzQkE7Z0JBQ0FGO2dCQUNBcUIsVUFBVTtnQkFDVkMsZUFBZTtZQUNqQjtRQUNGO1FBRUFILGFBQWFDLEdBQUcsQ0FBQ2xCLFlBQWFtQixRQUFRLEdBQUdiLFlBQVlELFNBQVNUO0lBQ2hFO0lBRUEsMkJBQTJCO0lBQzNCUSxnQkFBZ0JTLE9BQU8sQ0FBQ2pCLENBQUFBO1FBQ3RCLE1BQU1rQixTQUFTYix3QkFBd0JMO1FBQ3ZDLElBQUksQ0FBQ2tCLFFBQVE7UUFFYixNQUFNLEVBQUVoQixhQUFhLEVBQUVFLFVBQVUsRUFBRSxHQUFHYztRQUV0QyxJQUFJLENBQUNILFlBQVlJLEdBQUcsQ0FBQ2pCLGdCQUFnQjtZQUNuQ2EsWUFBWUssR0FBRyxDQUFDbEIsZUFBZSxJQUFJYztRQUNyQztRQUVBLE1BQU1LLGVBQWVOLFlBQVlPLEdBQUcsQ0FBQ3BCO1FBQ3JDLElBQUksQ0FBQ21CLGFBQWFGLEdBQUcsQ0FBQ2YsYUFBYTtZQUNqQ2lCLGFBQWFELEdBQUcsQ0FBQ2hCLFlBQVk7Z0JBQzNCQTtnQkFDQUY7Z0JBQ0FxQixVQUFVO2dCQUNWQyxlQUFlO1lBQ2pCO1FBQ0Y7UUFFQUgsYUFBYUMsR0FBRyxDQUFDbEIsWUFBYW9CLGFBQWEsR0FBR2QsWUFBWUQsU0FBU1Q7SUFDckU7SUFFQSwwQkFBMEI7SUFDMUIsTUFBTXlCLFdBQStCLEVBQUU7SUFDdkNWLFlBQVlFLE9BQU8sQ0FBQyxDQUFDUyxPQUFPeEI7UUFDMUIsTUFBTXlCLFlBQVlDLE1BQU1DLElBQUksQ0FBQ0gsTUFBTUksTUFBTSxJQUFJQyxJQUFJLENBQUMsQ0FBQ0MsR0FBR0MsSUFBTUQsRUFBRTVCLFVBQVUsR0FBRzZCLEVBQUU3QixVQUFVO1FBQ3ZGcUIsU0FBU1MsSUFBSSxDQUFDO1lBQ1poQztZQUNBd0IsT0FBT0M7WUFDUFEsWUFBWVIsVUFBVVMsTUFBTTtRQUM5QjtJQUNGO0lBRUEsTUFBTUMsU0FBU1osU0FBU00sSUFBSSxDQUFDLENBQUNDLEdBQUdDLElBQU1ELEVBQUU5QixhQUFhLEdBQUcrQixFQUFFL0IsYUFBYTtJQUN4RSxPQUFPbUM7QUFDVDtBQUVBOztDQUVDLEdBQ00sZUFBZUMsbUJBQW1CZCxhQUFxQjtJQUM1RCxJQUFJO1FBQ0YsTUFBTWUsV0FBVyxNQUFNQyxNQUFNaEI7UUFDN0IsSUFBSSxDQUFDZSxTQUFTRSxFQUFFLEVBQUU7WUFDaEIsTUFBTSxJQUFJQyxNQUFNLDhCQUFrRCxPQUFwQkgsU0FBU0ksVUFBVTtRQUNuRTtRQUVBLE1BQU1DLFVBQVUsTUFBTUwsU0FBU00sSUFBSTtRQUNuQyxNQUFNM0IsU0FBUzRCLHVCQUF1QkY7UUFDdEMsT0FBTzFCO0lBQ1QsRUFBRSxPQUFPNkIsT0FBTztRQUNkQyxRQUFRRCxLQUFLLENBQUMsNkJBQTZCQTtRQUMzQyxPQUFPLEVBQUU7SUFDWDtBQUNGO0FBRUE7O0NBRUMsR0FDTSxTQUFTRCx1QkFBdUJGLE9BQWU7SUFDcEQsNEVBQTRFO0lBQzVFLE1BQU1LLFlBQVlMLFFBQVFNLE9BQU8sQ0FBQyxXQUFXLElBQUlDLElBQUk7SUFDckQsTUFBTUMsUUFBUUgsVUFBVUksS0FBSyxDQUFDO0lBQzlCLE1BQU1DLFVBQTZCLEVBQUU7SUFFckNGLE1BQU1uQyxPQUFPLENBQUMsQ0FBQ3NDLE1BQU1DO1FBQ25CLE1BQU12RCxRQUFRc0QsS0FBS3RELEtBQUssQ0FBQztRQUN6QixJQUFJQSxPQUFPO1lBQ1QsTUFBTSxHQUFHd0QsU0FBU0MsU0FBU2IsS0FBSyxHQUFHNUM7WUFDbkMsTUFBTSxDQUFDMEQsU0FBU0MsUUFBUSxHQUFHSCxRQUFRSixLQUFLLENBQUMsS0FBS1EsR0FBRyxDQUFDQztZQUNsRCxNQUFNQyxZQUFZSixVQUFVLEtBQUtDO1lBRWpDTixRQUFRcEIsSUFBSSxDQUFDO2dCQUNYOEIsSUFBSSxTQUFlLE9BQU5SO2dCQUNiTztnQkFDQUwsU0FBU0EsUUFBUVAsSUFBSTtnQkFDckJOLE1BQU1BLEtBQUtNLElBQUk7Z0JBQ2ZjLFVBQVU7WUFDWjtRQUNGO0lBQ0Y7SUFFQSxPQUFPWDtBQUNUO0FBRUE7O0NBRUMsR0FDTSxTQUFTWSwwQkFDZFosT0FBMEIsRUFDMUJhLFdBQW1CO0lBRW5CLElBQUlDLGNBQXNDO0lBRTFDLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJZixRQUFRbEIsTUFBTSxFQUFFaUMsSUFBSztRQUN2QyxNQUFNQyxRQUFRaEIsT0FBTyxDQUFDZSxFQUFFO1FBQ3hCLE1BQU1FLFlBQVlqQixPQUFPLENBQUNlLElBQUksRUFBRTtRQUVoQyxJQUFJRixlQUFlRyxNQUFNUCxTQUFTLElBQUssRUFBQ1EsYUFBYUosY0FBY0ksVUFBVVIsU0FBUyxHQUFHO1lBQ3ZGSyxjQUFjRTtZQUNkO1FBQ0Y7SUFDRjtJQUVBLE9BQU9GO0FBQ1Q7QUFFQTs7Q0FFQyxHQUNNLFNBQVNJLDRCQUNkbEIsT0FBMEIsRUFDMUJhLFdBQW1CO0lBRW5CLE9BQU9iLFFBQVFPLEdBQUcsQ0FBQ1MsQ0FBQUE7WUFHTmhCO2VBSGdCO1lBQzNCLEdBQUdnQixLQUFLO1lBQ1JMLFVBQVVLLE1BQU1QLFNBQVMsSUFBSUksZUFDbkIsQ0FBQ2IsRUFBQUEsZ0JBQUFBLFFBQVFtQixJQUFJLENBQUNDLENBQUFBLElBQUtBLEVBQUVYLFNBQVMsR0FBR08sTUFBTVAsU0FBUyxlQUEvQ1Qsb0NBQUFBLGNBQWtEUyxTQUFTLEtBQUlZLFFBQU8sSUFBS1I7UUFDeEY7O0FBQ0Y7QUFnQkE7O0NBRUMsR0FDTSxTQUFTUyx1QkFBdUJDLFlBQXFDO0lBQzFFLE1BQU05RCxjQUFjLElBQUlDO0lBRXhCNkQsYUFBYTVELE9BQU8sQ0FBQzZELENBQUFBO1FBQ25CLElBQUksQ0FBQy9ELFlBQVlJLEdBQUcsQ0FBQzJELEtBQUtDLGNBQWMsR0FBRztZQUN6Q2hFLFlBQVlLLEdBQUcsQ0FBQzBELEtBQUtDLGNBQWMsRUFBRSxJQUFJL0Q7UUFDM0M7UUFFQSxNQUFNSyxlQUFlTixZQUFZTyxHQUFHLENBQUN3RCxLQUFLQyxjQUFjO1FBQ3hEMUQsYUFBYUQsR0FBRyxDQUFDMEQsS0FBS0UsV0FBVyxFQUFFO1lBQ2pDNUUsWUFBWTBFLEtBQUtFLFdBQVc7WUFDNUI5RSxlQUFlNEUsS0FBS0MsY0FBYztZQUNsQ3hELFVBQVV1RCxLQUFLRyxTQUFTO1lBQ3hCekQsZUFBZXNELEtBQUtJLGNBQWM7WUFDbENDLGdCQUFnQkwsS0FBS00sa0JBQWtCLEdBQUd0Qyx1QkFBdUJnQyxLQUFLTSxrQkFBa0IsSUFBSUM7WUFDNUZDLFVBQVVSLEtBQUtRLFFBQVE7UUFDekI7SUFDRjtJQUVBLE1BQU03RCxXQUErQixFQUFFO0lBQ3ZDVixZQUFZRSxPQUFPLENBQUMsQ0FBQ1MsT0FBT3hCO1FBQzFCLE1BQU15QixZQUFZQyxNQUFNQyxJQUFJLENBQUNILE1BQU1JLE1BQU0sSUFBSUMsSUFBSSxDQUFDLENBQUNDLEdBQUdDLElBQU1ELEVBQUU1QixVQUFVLEdBQUc2QixFQUFFN0IsVUFBVTtRQUN2RnFCLFNBQVNTLElBQUksQ0FBQztZQUNaaEM7WUFDQXdCLE9BQU9DO1lBQ1BRLFlBQVlSLFVBQVVTLE1BQU07UUFDOUI7SUFDRjtJQUVBLE9BQU9YLFNBQVNNLElBQUksQ0FBQyxDQUFDQyxHQUFHQyxJQUFNRCxFQUFFOUIsYUFBYSxHQUFHK0IsRUFBRS9CLGFBQWE7QUFDbEU7QUFFQTs7Q0FFQyxHQUNNLE1BQU1xRixnQkFBZ0I7SUFDM0JDLGdCQUFnQixDQUFDdEYsZUFBdUJFLGFBQ3RDLGlCQUF3Q0EsT0FBdkJGLGVBQWMsV0FBb0IsT0FBWEUsWUFBVztJQUNyRHFGLG1CQUFtQixDQUFDdkYsZ0JBQ2xCLGlCQUErQixPQUFkQSxlQUFjO0lBQ2pDd0YsZ0JBQWdCLENBQUN4RixlQUF1QkUsYUFDdEMsaUJBQXdDQSxPQUF2QkYsZUFBYyxXQUFvQixPQUFYRSxZQUFXO0lBQ3JEdUYsbUJBQW1CLENBQUN6RixlQUF1QkUsYUFDekMsaUJBQXdDQSxPQUF2QkYsZUFBYyxXQUFvQixPQUFYRSxZQUFXO0FBQ3ZELEVBQVciLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcYnJhZHlcXERlc2t0b3BcXFBvcnRmb2xpb1xcaGFjay10eC1tYW5nYS1uYXJyYXRpb25cXGZyb250ZW5kXFx1dGlsc1xccGFnZUF1ZGlvTWFuYWdlci50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBGaWxlOiBmcm9udGVuZC91dGlscy9wYWdlQXVkaW9NYW5hZ2VyLnRzXHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFBhZ2VBdWRpb0RhdGEge1xyXG4gIHBhZ2VOdW1iZXI6IG51bWJlcjtcclxuICBjaGFwdGVyTnVtYmVyOiBudW1iZXI7XHJcbiAgYXVkaW9Vcmw6IHN0cmluZztcclxuICB0cmFuc2NyaXB0VXJsOiBzdHJpbmc7XHJcbiAgdHJhbnNjcmlwdERhdGE/OiBUcmFuc2NyaXB0RW50cnlbXTtcclxuICBkdXJhdGlvbj86IG51bWJlcjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBUcmFuc2NyaXB0RW50cnkge1xyXG4gIGlkOiBzdHJpbmc7XHJcbiAgdGltZXN0YW1wOiBudW1iZXI7XHJcbiAgc3BlYWtlcjogc3RyaW5nO1xyXG4gIHRleHQ6IHN0cmluZztcclxuICBpc0FjdGl2ZT86IGJvb2xlYW47XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQ2hhcHRlckF1ZGlvRGF0YSB7XHJcbiAgY2hhcHRlck51bWJlcjogbnVtYmVyO1xyXG4gIHBhZ2VzOiBQYWdlQXVkaW9EYXRhW107XHJcbiAgdG90YWxQYWdlczogbnVtYmVyO1xyXG59XHJcblxyXG4vKipcclxuICogUGFyc2VzIGZpbGVuYW1lIHRvIGV4dHJhY3QgY2hhcHRlciBhbmQgcGFnZSBpbmZvcm1hdGlvblxyXG4gKiBFeHBlY3RlZCBmb3JtYXQ6IGNoe2NoYXB0ZXJ9X3BhZ2V7cGFnZX1fZGlhbG9ndWVfe3RpbWVzdGFtcH0ubXAzXHJcbiAqIEV4YW1wbGU6IGNoMDFfcGFnZTAxX2RpYWxvZ3VlXzIwMjUxMDE4XzIyMDcxNy5tcDNcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUF1ZGlvRmlsZW5hbWUoZmlsZW5hbWU6IHN0cmluZyk6IHsgY2hhcHRlck51bWJlcjogbnVtYmVyOyBwYWdlTnVtYmVyOiBudW1iZXIgfSB8IG51bGwge1xyXG4gIGNvbnN0IG1hdGNoID0gZmlsZW5hbWUubWF0Y2goL2NoKFxcZCspX3BhZ2UoXFxkKylfZGlhbG9ndWUvKTtcclxuICBpZiAoIW1hdGNoKSByZXR1cm4gbnVsbDtcclxuICBcclxuICByZXR1cm4ge1xyXG4gICAgY2hhcHRlck51bWJlcjogcGFyc2VJbnQobWF0Y2hbMV0sIDEwKSxcclxuICAgIHBhZ2VOdW1iZXI6IHBhcnNlSW50KG1hdGNoWzJdLCAxMClcclxuICB9O1xyXG59XHJcblxyXG4vKipcclxuICogUGFyc2VzIHRyYW5zY3JpcHQgZmlsZW5hbWUgdG8gZXh0cmFjdCBjaGFwdGVyIGFuZCBwYWdlIGluZm9ybWF0aW9uXHJcbiAqIEV4cGVjdGVkIGZvcm1hdDogY2h7Y2hhcHRlcn1fcGFnZXtwYWdlfV90cmFuc2NyaXB0X3t0aW1lc3RhbXB9LnR4dFxyXG4gKiBFeGFtcGxlOiBjaDAxX3BhZ2UwMV90cmFuc2NyaXB0XzIwMjUxMDE4XzIyMDcxNy50eHRcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVRyYW5zY3JpcHRGaWxlbmFtZShmaWxlbmFtZTogc3RyaW5nKTogeyBjaGFwdGVyTnVtYmVyOiBudW1iZXI7IHBhZ2VOdW1iZXI6IG51bWJlciB9IHwgbnVsbCB7XHJcbiAgY29uc3QgbWF0Y2ggPSBmaWxlbmFtZS5tYXRjaCgvY2goXFxkKylfcGFnZShcXGQrKV90cmFuc2NyaXB0Lyk7XHJcbiAgaWYgKCFtYXRjaCkgcmV0dXJuIG51bGw7XHJcbiAgXHJcbiAgcmV0dXJuIHtcclxuICAgIGNoYXB0ZXJOdW1iZXI6IHBhcnNlSW50KG1hdGNoWzFdLCAxMCksXHJcbiAgICBwYWdlTnVtYmVyOiBwYXJzZUludChtYXRjaFsyXSwgMTApXHJcbiAgfTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEdyb3VwcyBhdWRpbyBhbmQgdHJhbnNjcmlwdCBmaWxlcyBieSBjaGFwdGVyIGFuZCBwYWdlXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gb3JnYW5pemVQYWdlQXVkaW9GaWxlcyhcclxuICBhdWRpb0ZpbGVzOiBzdHJpbmdbXSxcclxuICB0cmFuc2NyaXB0RmlsZXM6IHN0cmluZ1tdLFxyXG4gIGJhc2VVcmw6IHN0cmluZyA9ICcvYXNzZXRzJ1xyXG4pOiBDaGFwdGVyQXVkaW9EYXRhW10ge1xyXG4gIC8vIEVuc3VyZSB3ZSBqb2luIGJhc2VVcmwgYW5kIGZpbGVuYW1lcyB3aXRob3V0IHByb2R1Y2luZyBwcm90b2NvbC1yZWxhdGl2ZSBVUkxzIChlLmcuLCAvL2ZpbGUpXHJcbiAgY29uc3Qgam9pblVybFBhdGggPSAocm9vdDogc3RyaW5nLCBmaWxlbmFtZTogc3RyaW5nKTogc3RyaW5nID0+IHtcclxuICAgIGlmICghcm9vdCB8fCByb290ID09PSAnLycpIHtcclxuICAgICAgcmV0dXJuIGAvJHtmaWxlbmFtZX1gO1xyXG4gICAgfVxyXG4gICAgY29uc3QgdHJpbW1lZCA9IHJvb3QuZW5kc1dpdGgoJy8nKSA/IHJvb3Quc2xpY2UoMCwgLTEpIDogcm9vdDtcclxuICAgIHJldHVybiBgJHt0cmltbWVkfS8ke2ZpbGVuYW1lfWA7XHJcbiAgfTtcclxuICBjb25zdCBjaGFwdGVyc01hcCA9IG5ldyBNYXA8bnVtYmVyLCBNYXA8bnVtYmVyLCBQYWdlQXVkaW9EYXRhPj4oKTtcclxuICBcclxuICAvLyBQcm9jZXNzIGF1ZGlvIGZpbGVzXHJcbiAgYXVkaW9GaWxlcy5mb3JFYWNoKGZpbGVuYW1lID0+IHtcclxuICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlQXVkaW9GaWxlbmFtZShmaWxlbmFtZSk7XHJcbiAgICBpZiAoIXBhcnNlZCkgcmV0dXJuO1xyXG4gICAgXHJcbiAgICBjb25zdCB7IGNoYXB0ZXJOdW1iZXIsIHBhZ2VOdW1iZXIgfSA9IHBhcnNlZDtcclxuICAgIFxyXG4gICAgaWYgKCFjaGFwdGVyc01hcC5oYXMoY2hhcHRlck51bWJlcikpIHtcclxuICAgICAgY2hhcHRlcnNNYXAuc2V0KGNoYXB0ZXJOdW1iZXIsIG5ldyBNYXAoKSk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGNvbnN0IGNoYXB0ZXJQYWdlcyA9IGNoYXB0ZXJzTWFwLmdldChjaGFwdGVyTnVtYmVyKSE7XHJcbiAgICBpZiAoIWNoYXB0ZXJQYWdlcy5oYXMocGFnZU51bWJlcikpIHtcclxuICAgICAgY2hhcHRlclBhZ2VzLnNldChwYWdlTnVtYmVyLCB7XHJcbiAgICAgICAgcGFnZU51bWJlcixcclxuICAgICAgICBjaGFwdGVyTnVtYmVyLFxyXG4gICAgICAgIGF1ZGlvVXJsOiAnJyxcclxuICAgICAgICB0cmFuc2NyaXB0VXJsOiAnJ1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgY2hhcHRlclBhZ2VzLmdldChwYWdlTnVtYmVyKSEuYXVkaW9VcmwgPSBqb2luVXJsUGF0aChiYXNlVXJsLCBmaWxlbmFtZSk7XHJcbiAgfSk7XHJcbiAgXHJcbiAgLy8gUHJvY2VzcyB0cmFuc2NyaXB0IGZpbGVzXHJcbiAgdHJhbnNjcmlwdEZpbGVzLmZvckVhY2goZmlsZW5hbWUgPT4ge1xyXG4gICAgY29uc3QgcGFyc2VkID0gcGFyc2VUcmFuc2NyaXB0RmlsZW5hbWUoZmlsZW5hbWUpO1xyXG4gICAgaWYgKCFwYXJzZWQpIHJldHVybjtcclxuICAgIFxyXG4gICAgY29uc3QgeyBjaGFwdGVyTnVtYmVyLCBwYWdlTnVtYmVyIH0gPSBwYXJzZWQ7XHJcbiAgICBcclxuICAgIGlmICghY2hhcHRlcnNNYXAuaGFzKGNoYXB0ZXJOdW1iZXIpKSB7XHJcbiAgICAgIGNoYXB0ZXJzTWFwLnNldChjaGFwdGVyTnVtYmVyLCBuZXcgTWFwKCkpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBjb25zdCBjaGFwdGVyUGFnZXMgPSBjaGFwdGVyc01hcC5nZXQoY2hhcHRlck51bWJlcikhO1xyXG4gICAgaWYgKCFjaGFwdGVyUGFnZXMuaGFzKHBhZ2VOdW1iZXIpKSB7XHJcbiAgICAgIGNoYXB0ZXJQYWdlcy5zZXQocGFnZU51bWJlciwge1xyXG4gICAgICAgIHBhZ2VOdW1iZXIsXHJcbiAgICAgICAgY2hhcHRlck51bWJlcixcclxuICAgICAgICBhdWRpb1VybDogJycsXHJcbiAgICAgICAgdHJhbnNjcmlwdFVybDogJydcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGNoYXB0ZXJQYWdlcy5nZXQocGFnZU51bWJlcikhLnRyYW5zY3JpcHRVcmwgPSBqb2luVXJsUGF0aChiYXNlVXJsLCBmaWxlbmFtZSk7XHJcbiAgfSk7XHJcbiAgXHJcbiAgLy8gQ29udmVydCB0byBhcnJheSBmb3JtYXRcclxuICBjb25zdCBjaGFwdGVyczogQ2hhcHRlckF1ZGlvRGF0YVtdID0gW107XHJcbiAgY2hhcHRlcnNNYXAuZm9yRWFjaCgocGFnZXMsIGNoYXB0ZXJOdW1iZXIpID0+IHtcclxuICAgIGNvbnN0IHBhZ2VBcnJheSA9IEFycmF5LmZyb20ocGFnZXMudmFsdWVzKCkpLnNvcnQoKGEsIGIpID0+IGEucGFnZU51bWJlciAtIGIucGFnZU51bWJlcik7XHJcbiAgICBjaGFwdGVycy5wdXNoKHtcclxuICAgICAgY2hhcHRlck51bWJlcixcclxuICAgICAgcGFnZXM6IHBhZ2VBcnJheSxcclxuICAgICAgdG90YWxQYWdlczogcGFnZUFycmF5Lmxlbmd0aFxyXG4gICAgfSk7XHJcbiAgfSk7XHJcbiAgXHJcbiAgY29uc3QgcmVzdWx0ID0gY2hhcHRlcnMuc29ydCgoYSwgYikgPT4gYS5jaGFwdGVyTnVtYmVyIC0gYi5jaGFwdGVyTnVtYmVyKTtcclxuICByZXR1cm4gcmVzdWx0O1xyXG59XHJcblxyXG4vKipcclxuICogTG9hZHMgdHJhbnNjcmlwdCBkYXRhIGZyb20gVVJMXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gbG9hZFRyYW5zY3JpcHREYXRhKHRyYW5zY3JpcHRVcmw6IHN0cmluZyk6IFByb21pc2U8VHJhbnNjcmlwdEVudHJ5W10+IHtcclxuICB0cnkge1xyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh0cmFuc2NyaXB0VXJsKTtcclxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gbG9hZCB0cmFuc2NyaXB0OiAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGNvbnN0IGNvbnRlbnQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XHJcbiAgICBjb25zdCBwYXJzZWQgPSBwYXJzZVRyYW5zY3JpcHRDb250ZW50KGNvbnRlbnQpO1xyXG4gICAgcmV0dXJuIHBhcnNlZDtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgbG9hZGluZyB0cmFuc2NyaXB0OicsIGVycm9yKTtcclxuICAgIHJldHVybiBbXTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBQYXJzZXMgdHJhbnNjcmlwdCBjb250ZW50IGludG8gc3RydWN0dXJlZCBlbnRyaWVzXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VUcmFuc2NyaXB0Q29udGVudChjb250ZW50OiBzdHJpbmcpOiBUcmFuc2NyaXB0RW50cnlbXSB7XHJcbiAgLy8gUmVtb3ZlIHBvdGVudGlhbCBVVEYtOCBCT00gdG8gZW5zdXJlIHRoZSBmaXJzdCB0aW1lc3RhbXAgcGFyc2VzIGNvcnJlY3RseVxyXG4gIGNvbnN0IHNhbml0aXplZCA9IGNvbnRlbnQucmVwbGFjZSgvXlxcdUZFRkYvLCAnJykudHJpbSgpO1xyXG4gIGNvbnN0IGxpbmVzID0gc2FuaXRpemVkLnNwbGl0KCdcXG4nKTtcclxuICBjb25zdCBlbnRyaWVzOiBUcmFuc2NyaXB0RW50cnlbXSA9IFtdO1xyXG4gIFxyXG4gIGxpbmVzLmZvckVhY2goKGxpbmUsIGluZGV4KSA9PiB7XHJcbiAgICBjb25zdCBtYXRjaCA9IGxpbmUubWF0Y2goL14oXFxkezJ9OlxcZHsyfSlcXHMrKC4rPyk6XFxzKyguKykkLyk7XHJcbiAgICBpZiAobWF0Y2gpIHtcclxuICAgICAgY29uc3QgWywgdGltZVN0ciwgc3BlYWtlciwgdGV4dF0gPSBtYXRjaDtcclxuICAgICAgY29uc3QgW21pbnV0ZXMsIHNlY29uZHNdID0gdGltZVN0ci5zcGxpdCgnOicpLm1hcChOdW1iZXIpO1xyXG4gICAgICBjb25zdCB0aW1lc3RhbXAgPSBtaW51dGVzICogNjAgKyBzZWNvbmRzO1xyXG4gICAgICBcclxuICAgICAgZW50cmllcy5wdXNoKHtcclxuICAgICAgICBpZDogYGVudHJ5LSR7aW5kZXh9YCxcclxuICAgICAgICB0aW1lc3RhbXAsXHJcbiAgICAgICAgc3BlYWtlcjogc3BlYWtlci50cmltKCksXHJcbiAgICAgICAgdGV4dDogdGV4dC50cmltKCksXHJcbiAgICAgICAgaXNBY3RpdmU6IGZhbHNlXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH0pO1xyXG4gIFxyXG4gIHJldHVybiBlbnRyaWVzO1xyXG59XHJcblxyXG4vKipcclxuICogRmluZHMgdGhlIGFjdGl2ZSB0cmFuc2NyaXB0IGVudHJ5IGJhc2VkIG9uIGN1cnJlbnQgdGltZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRBY3RpdmVUcmFuc2NyaXB0RW50cnkoXHJcbiAgZW50cmllczogVHJhbnNjcmlwdEVudHJ5W10sIFxyXG4gIGN1cnJlbnRUaW1lOiBudW1iZXJcclxuKTogVHJhbnNjcmlwdEVudHJ5IHwgbnVsbCB7XHJcbiAgbGV0IGFjdGl2ZUVudHJ5OiBUcmFuc2NyaXB0RW50cnkgfCBudWxsID0gbnVsbDtcclxuICBcclxuICBmb3IgKGxldCBpID0gMDsgaSA8IGVudHJpZXMubGVuZ3RoOyBpKyspIHtcclxuICAgIGNvbnN0IGVudHJ5ID0gZW50cmllc1tpXTtcclxuICAgIGNvbnN0IG5leHRFbnRyeSA9IGVudHJpZXNbaSArIDFdO1xyXG4gICAgXHJcbiAgICBpZiAoY3VycmVudFRpbWUgPj0gZW50cnkudGltZXN0YW1wICYmICghbmV4dEVudHJ5IHx8IGN1cnJlbnRUaW1lIDwgbmV4dEVudHJ5LnRpbWVzdGFtcCkpIHtcclxuICAgICAgYWN0aXZlRW50cnkgPSBlbnRyeTtcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgfVxyXG4gIFxyXG4gIHJldHVybiBhY3RpdmVFbnRyeTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFVwZGF0ZXMgYWN0aXZlIHN0YXRlIGZvciB0cmFuc2NyaXB0IGVudHJpZXNcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVUcmFuc2NyaXB0QWN0aXZlU3RhdGUoXHJcbiAgZW50cmllczogVHJhbnNjcmlwdEVudHJ5W10sIFxyXG4gIGN1cnJlbnRUaW1lOiBudW1iZXJcclxuKTogVHJhbnNjcmlwdEVudHJ5W10ge1xyXG4gIHJldHVybiBlbnRyaWVzLm1hcChlbnRyeSA9PiAoe1xyXG4gICAgLi4uZW50cnksXHJcbiAgICBpc0FjdGl2ZTogZW50cnkudGltZXN0YW1wIDw9IGN1cnJlbnRUaW1lICYmIFxyXG4gICAgICAgICAgICAgIChlbnRyaWVzLmZpbmQoZSA9PiBlLnRpbWVzdGFtcCA+IGVudHJ5LnRpbWVzdGFtcCk/LnRpbWVzdGFtcCB8fCBJbmZpbml0eSkgPiBjdXJyZW50VGltZVxyXG4gIH0pKTtcclxufVxyXG5cclxuLy8gQVBJIEludGVncmF0aW9uIEhlbHBlcnMgKGZvciBmdXR1cmUgU3VwYWJhc2UgaW50ZWdyYXRpb24pXHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFN1cGFiYXNlUGFnZUF1ZGlvRGF0YSB7XHJcbiAgaWQ6IHN0cmluZztcclxuICBjaGFwdGVyX251bWJlcjogbnVtYmVyO1xyXG4gIHBhZ2VfbnVtYmVyOiBudW1iZXI7XHJcbiAgYXVkaW9fdXJsOiBzdHJpbmc7XHJcbiAgdHJhbnNjcmlwdF91cmw6IHN0cmluZztcclxuICB0cmFuc2NyaXB0X2NvbnRlbnQ/OiBzdHJpbmc7XHJcbiAgZHVyYXRpb24/OiBudW1iZXI7XHJcbiAgY3JlYXRlZF9hdDogc3RyaW5nO1xyXG4gIHVwZGF0ZWRfYXQ6IHN0cmluZztcclxufVxyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIFN1cGFiYXNlIGRhdGEgdG8gbG9jYWwgZm9ybWF0XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY29udmVydFN1cGFiYXNlVG9Mb2NhbChzdXBhYmFzZURhdGE6IFN1cGFiYXNlUGFnZUF1ZGlvRGF0YVtdKTogQ2hhcHRlckF1ZGlvRGF0YVtdIHtcclxuICBjb25zdCBjaGFwdGVyc01hcCA9IG5ldyBNYXA8bnVtYmVyLCBNYXA8bnVtYmVyLCBQYWdlQXVkaW9EYXRhPj4oKTtcclxuICBcclxuICBzdXBhYmFzZURhdGEuZm9yRWFjaChpdGVtID0+IHtcclxuICAgIGlmICghY2hhcHRlcnNNYXAuaGFzKGl0ZW0uY2hhcHRlcl9udW1iZXIpKSB7XHJcbiAgICAgIGNoYXB0ZXJzTWFwLnNldChpdGVtLmNoYXB0ZXJfbnVtYmVyLCBuZXcgTWFwKCkpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBjb25zdCBjaGFwdGVyUGFnZXMgPSBjaGFwdGVyc01hcC5nZXQoaXRlbS5jaGFwdGVyX251bWJlcikhO1xyXG4gICAgY2hhcHRlclBhZ2VzLnNldChpdGVtLnBhZ2VfbnVtYmVyLCB7XHJcbiAgICAgIHBhZ2VOdW1iZXI6IGl0ZW0ucGFnZV9udW1iZXIsXHJcbiAgICAgIGNoYXB0ZXJOdW1iZXI6IGl0ZW0uY2hhcHRlcl9udW1iZXIsXHJcbiAgICAgIGF1ZGlvVXJsOiBpdGVtLmF1ZGlvX3VybCxcclxuICAgICAgdHJhbnNjcmlwdFVybDogaXRlbS50cmFuc2NyaXB0X3VybCxcclxuICAgICAgdHJhbnNjcmlwdERhdGE6IGl0ZW0udHJhbnNjcmlwdF9jb250ZW50ID8gcGFyc2VUcmFuc2NyaXB0Q29udGVudChpdGVtLnRyYW5zY3JpcHRfY29udGVudCkgOiB1bmRlZmluZWQsXHJcbiAgICAgIGR1cmF0aW9uOiBpdGVtLmR1cmF0aW9uXHJcbiAgICB9KTtcclxuICB9KTtcclxuICBcclxuICBjb25zdCBjaGFwdGVyczogQ2hhcHRlckF1ZGlvRGF0YVtdID0gW107XHJcbiAgY2hhcHRlcnNNYXAuZm9yRWFjaCgocGFnZXMsIGNoYXB0ZXJOdW1iZXIpID0+IHtcclxuICAgIGNvbnN0IHBhZ2VBcnJheSA9IEFycmF5LmZyb20ocGFnZXMudmFsdWVzKCkpLnNvcnQoKGEsIGIpID0+IGEucGFnZU51bWJlciAtIGIucGFnZU51bWJlcik7XHJcbiAgICBjaGFwdGVycy5wdXNoKHtcclxuICAgICAgY2hhcHRlck51bWJlcixcclxuICAgICAgcGFnZXM6IHBhZ2VBcnJheSxcclxuICAgICAgdG90YWxQYWdlczogcGFnZUFycmF5Lmxlbmd0aFxyXG4gICAgfSk7XHJcbiAgfSk7XHJcbiAgXHJcbiAgcmV0dXJuIGNoYXB0ZXJzLnNvcnQoKGEsIGIpID0+IGEuY2hhcHRlck51bWJlciAtIGIuY2hhcHRlck51bWJlcik7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBUEkgZW5kcG9pbnQgaGVscGVycyBmb3IgZnV0dXJlIGludGVncmF0aW9uXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgQVBJX0VORFBPSU5UUyA9IHtcclxuICBHRVRfUEFHRV9BVURJTzogKGNoYXB0ZXJOdW1iZXI6IG51bWJlciwgcGFnZU51bWJlcjogbnVtYmVyKSA9PiBcclxuICAgIGAvYXBpL2NoYXB0ZXJzLyR7Y2hhcHRlck51bWJlcn0vcGFnZXMvJHtwYWdlTnVtYmVyfS9hdWRpb2AsXHJcbiAgR0VUX0NIQVBURVJfQVVESU86IChjaGFwdGVyTnVtYmVyOiBudW1iZXIpID0+IFxyXG4gICAgYC9hcGkvY2hhcHRlcnMvJHtjaGFwdGVyTnVtYmVyfS9hdWRpb2AsXHJcbiAgR0VUX1RSQU5TQ1JJUFQ6IChjaGFwdGVyTnVtYmVyOiBudW1iZXIsIHBhZ2VOdW1iZXI6IG51bWJlcikgPT4gXHJcbiAgICBgL2FwaS9jaGFwdGVycy8ke2NoYXB0ZXJOdW1iZXJ9L3BhZ2VzLyR7cGFnZU51bWJlcn0vdHJhbnNjcmlwdGAsXHJcbiAgVVBMT0FEX1BBR0VfQVVESU86IChjaGFwdGVyTnVtYmVyOiBudW1iZXIsIHBhZ2VOdW1iZXI6IG51bWJlcikgPT4gXHJcbiAgICBgL2FwaS9jaGFwdGVycy8ke2NoYXB0ZXJOdW1iZXJ9L3BhZ2VzLyR7cGFnZU51bWJlcn0vYXVkaW8vdXBsb2FkYFxyXG59IGFzIGNvbnN0O1xyXG4iXSwibmFtZXMiOlsicGFyc2VBdWRpb0ZpbGVuYW1lIiwiZmlsZW5hbWUiLCJtYXRjaCIsImNoYXB0ZXJOdW1iZXIiLCJwYXJzZUludCIsInBhZ2VOdW1iZXIiLCJwYXJzZVRyYW5zY3JpcHRGaWxlbmFtZSIsIm9yZ2FuaXplUGFnZUF1ZGlvRmlsZXMiLCJhdWRpb0ZpbGVzIiwidHJhbnNjcmlwdEZpbGVzIiwiYmFzZVVybCIsImpvaW5VcmxQYXRoIiwicm9vdCIsInRyaW1tZWQiLCJlbmRzV2l0aCIsInNsaWNlIiwiY2hhcHRlcnNNYXAiLCJNYXAiLCJmb3JFYWNoIiwicGFyc2VkIiwiaGFzIiwic2V0IiwiY2hhcHRlclBhZ2VzIiwiZ2V0IiwiYXVkaW9VcmwiLCJ0cmFuc2NyaXB0VXJsIiwiY2hhcHRlcnMiLCJwYWdlcyIsInBhZ2VBcnJheSIsIkFycmF5IiwiZnJvbSIsInZhbHVlcyIsInNvcnQiLCJhIiwiYiIsInB1c2giLCJ0b3RhbFBhZ2VzIiwibGVuZ3RoIiwicmVzdWx0IiwibG9hZFRyYW5zY3JpcHREYXRhIiwicmVzcG9uc2UiLCJmZXRjaCIsIm9rIiwiRXJyb3IiLCJzdGF0dXNUZXh0IiwiY29udGVudCIsInRleHQiLCJwYXJzZVRyYW5zY3JpcHRDb250ZW50IiwiZXJyb3IiLCJjb25zb2xlIiwic2FuaXRpemVkIiwicmVwbGFjZSIsInRyaW0iLCJsaW5lcyIsInNwbGl0IiwiZW50cmllcyIsImxpbmUiLCJpbmRleCIsInRpbWVTdHIiLCJzcGVha2VyIiwibWludXRlcyIsInNlY29uZHMiLCJtYXAiLCJOdW1iZXIiLCJ0aW1lc3RhbXAiLCJpZCIsImlzQWN0aXZlIiwiZmluZEFjdGl2ZVRyYW5zY3JpcHRFbnRyeSIsImN1cnJlbnRUaW1lIiwiYWN0aXZlRW50cnkiLCJpIiwiZW50cnkiLCJuZXh0RW50cnkiLCJ1cGRhdGVUcmFuc2NyaXB0QWN0aXZlU3RhdGUiLCJmaW5kIiwiZSIsIkluZmluaXR5IiwiY29udmVydFN1cGFiYXNlVG9Mb2NhbCIsInN1cGFiYXNlRGF0YSIsIml0ZW0iLCJjaGFwdGVyX251bWJlciIsInBhZ2VfbnVtYmVyIiwiYXVkaW9fdXJsIiwidHJhbnNjcmlwdF91cmwiLCJ0cmFuc2NyaXB0RGF0YSIsInRyYW5zY3JpcHRfY29udGVudCIsInVuZGVmaW5lZCIsImR1cmF0aW9uIiwiQVBJX0VORFBPSU5UUyIsIkdFVF9QQUdFX0FVRElPIiwiR0VUX0NIQVBURVJfQVVESU8iLCJHRVRfVFJBTlNDUklQVCIsIlVQTE9BRF9QQUdFX0FVRElPIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./utils/pageAudioManager.ts\n"));

/***/ })

});