"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./utils/pageAudioManager.ts":
/*!***********************************!*\
  !*** ./utils/pageAudioManager.ts ***!
  \***********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   API_ENDPOINTS: () => (/* binding */ API_ENDPOINTS),\n/* harmony export */   convertSupabaseToLocal: () => (/* binding */ convertSupabaseToLocal),\n/* harmony export */   findActiveTranscriptEntry: () => (/* binding */ findActiveTranscriptEntry),\n/* harmony export */   loadTranscriptData: () => (/* binding */ loadTranscriptData),\n/* harmony export */   organizePageAudioFiles: () => (/* binding */ organizePageAudioFiles),\n/* harmony export */   parseAudioFilename: () => (/* binding */ parseAudioFilename),\n/* harmony export */   parseTranscriptContent: () => (/* binding */ parseTranscriptContent),\n/* harmony export */   parseTranscriptFilename: () => (/* binding */ parseTranscriptFilename),\n/* harmony export */   updateTranscriptActiveState: () => (/* binding */ updateTranscriptActiveState)\n/* harmony export */ });\n// File: frontend/utils/pageAudioManager.ts\n/**\r\n * Parses filename to extract chapter and page information\r\n * Expected format: ch{chapter}_page{page}_dialogue_{timestamp}.mp3\r\n * Example: ch01_page01_dialogue_20251018_220717.mp3\r\n */ function parseAudioFilename(filename) {\n    const match = filename.match(/ch(\\d+)_page(\\d+)_dialogue/);\n    if (!match) return null;\n    return {\n        chapterNumber: parseInt(match[1], 10),\n        pageNumber: parseInt(match[2], 10)\n    };\n}\n/**\r\n * Parses transcript filename to extract chapter and page information\r\n * Expected format: ch{chapter}_page{page}_transcript_{timestamp}.txt\r\n * Example: ch01_page01_transcript_20251018_220717.txt\r\n */ function parseTranscriptFilename(filename) {\n    const match = filename.match(/ch(\\d+)_page(\\d+)_transcript/);\n    if (!match) return null;\n    return {\n        chapterNumber: parseInt(match[1], 10),\n        pageNumber: parseInt(match[2], 10)\n    };\n}\n/**\r\n * Groups audio and transcript files by chapter and page\r\n */ function organizePageAudioFiles(audioFiles, transcriptFiles) {\n    let baseUrl = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : '/assets';\n    // Ensure we join baseUrl and filenames without producing protocol-relative URLs (e.g., //file)\n    const joinUrlPath = (root, filename)=>{\n        if (!root || root === '/') {\n            return \"/\".concat(filename);\n        }\n        const trimmed = root.endsWith('/') ? root.slice(0, -1) : root;\n        return \"\".concat(trimmed, \"/\").concat(filename);\n    };\n    const chaptersMap = new Map();\n    // Process audio files\n    audioFiles.forEach((filename)=>{\n        const parsed = parseAudioFilename(filename);\n        if (!parsed) return;\n        const { chapterNumber, pageNumber } = parsed;\n        if (!chaptersMap.has(chapterNumber)) {\n            chaptersMap.set(chapterNumber, new Map());\n        }\n        const chapterPages = chaptersMap.get(chapterNumber);\n        if (!chapterPages.has(pageNumber)) {\n            chapterPages.set(pageNumber, {\n                pageNumber,\n                chapterNumber,\n                audioUrl: '',\n                transcriptUrl: ''\n            });\n        }\n        chapterPages.get(pageNumber).audioUrl = joinUrlPath(baseUrl, filename);\n    });\n    // Process transcript files\n    transcriptFiles.forEach((filename)=>{\n        const parsed = parseTranscriptFilename(filename);\n        if (!parsed) return;\n        const { chapterNumber, pageNumber } = parsed;\n        if (!chaptersMap.has(chapterNumber)) {\n            chaptersMap.set(chapterNumber, new Map());\n        }\n        const chapterPages = chaptersMap.get(chapterNumber);\n        if (!chapterPages.has(pageNumber)) {\n            chapterPages.set(pageNumber, {\n                pageNumber,\n                chapterNumber,\n                audioUrl: '',\n                transcriptUrl: ''\n            });\n        }\n        chapterPages.get(pageNumber).transcriptUrl = joinUrlPath(baseUrl, filename);\n    });\n    // Convert to array format\n    const chapters = [];\n    chaptersMap.forEach((pages, chapterNumber)=>{\n        const pageArray = Array.from(pages.values()).sort((a, b)=>a.pageNumber - b.pageNumber);\n        chapters.push({\n            chapterNumber,\n            pages: pageArray,\n            totalPages: pageArray.length\n        });\n    });\n    const result = chapters.sort((a, b)=>a.chapterNumber - b.chapterNumber);\n    return result;\n}\n/**\r\n * Loads transcript data from URL\r\n */ async function loadTranscriptData(transcriptUrl) {\n    try {\n        const response = await fetch(transcriptUrl);\n        if (!response.ok) {\n            throw new Error(\"Failed to load transcript: \".concat(response.statusText));\n        }\n        const content = await response.text();\n        const parsed = parseTranscriptContent(content);\n        return parsed;\n    } catch (error) {\n        console.error('Error loading transcript:', error);\n        return [];\n    }\n}\n/**\r\n * Parses transcript content into structured entries\r\n */ function parseTranscriptContent(content) {\n    const lines = content.trim().split('\\n');\n    const entries = [];\n    lines.forEach((line, index)=>{\n        const match = line.match(/^(\\d{2}:\\d{2})\\s+(.+?):\\s+(.+)$/);\n        if (match) {\n            const [, timeStr, speaker, text] = match;\n            const [minutes, seconds] = timeStr.split(':').map(Number);\n            const timestamp = minutes * 60 + seconds;\n            entries.push({\n                id: \"entry-\".concat(index),\n                timestamp,\n                speaker: speaker.trim(),\n                text: text.trim(),\n                isActive: false\n            });\n        }\n    });\n    return entries;\n}\n/**\r\n * Finds the active transcript entry based on current time\r\n */ function findActiveTranscriptEntry(entries, currentTime) {\n    let activeEntry = null;\n    for(let i = 0; i < entries.length; i++){\n        const entry = entries[i];\n        const nextEntry = entries[i + 1];\n        if (currentTime >= entry.timestamp && (!nextEntry || currentTime < nextEntry.timestamp)) {\n            activeEntry = entry;\n            break;\n        }\n    }\n    return activeEntry;\n}\n/**\r\n * Updates active state for transcript entries\r\n */ function updateTranscriptActiveState(entries, currentTime) {\n    return entries.map((entry)=>{\n        var _entries_find;\n        return {\n            ...entry,\n            isActive: entry.timestamp <= currentTime && (((_entries_find = entries.find((e)=>e.timestamp > entry.timestamp)) === null || _entries_find === void 0 ? void 0 : _entries_find.timestamp) || Infinity) > currentTime\n        };\n    });\n}\n/**\r\n * Converts Supabase data to local format\r\n */ function convertSupabaseToLocal(supabaseData) {\n    const chaptersMap = new Map();\n    supabaseData.forEach((item)=>{\n        if (!chaptersMap.has(item.chapter_number)) {\n            chaptersMap.set(item.chapter_number, new Map());\n        }\n        const chapterPages = chaptersMap.get(item.chapter_number);\n        chapterPages.set(item.page_number, {\n            pageNumber: item.page_number,\n            chapterNumber: item.chapter_number,\n            audioUrl: item.audio_url,\n            transcriptUrl: item.transcript_url,\n            transcriptData: item.transcript_content ? parseTranscriptContent(item.transcript_content) : undefined,\n            duration: item.duration\n        });\n    });\n    const chapters = [];\n    chaptersMap.forEach((pages, chapterNumber)=>{\n        const pageArray = Array.from(pages.values()).sort((a, b)=>a.pageNumber - b.pageNumber);\n        chapters.push({\n            chapterNumber,\n            pages: pageArray,\n            totalPages: pageArray.length\n        });\n    });\n    return chapters.sort((a, b)=>a.chapterNumber - b.chapterNumber);\n}\n/**\r\n * API endpoint helpers for future integration\r\n */ const API_ENDPOINTS = {\n    GET_PAGE_AUDIO: (chapterNumber, pageNumber)=>\"/api/chapters/\".concat(chapterNumber, \"/pages/\").concat(pageNumber, \"/audio\"),\n    GET_CHAPTER_AUDIO: (chapterNumber)=>\"/api/chapters/\".concat(chapterNumber, \"/audio\"),\n    GET_TRANSCRIPT: (chapterNumber, pageNumber)=>\"/api/chapters/\".concat(chapterNumber, \"/pages/\").concat(pageNumber, \"/transcript\"),\n    UPLOAD_PAGE_AUDIO: (chapterNumber, pageNumber)=>\"/api/chapters/\".concat(chapterNumber, \"/pages/\").concat(pageNumber, \"/audio/upload\")\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3V0aWxzL3BhZ2VBdWRpb01hbmFnZXIudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQUEsMkNBQTJDO0FBeUIzQzs7OztDQUlDLEdBQ00sU0FBU0EsbUJBQW1CQyxRQUFnQjtJQUNqRCxNQUFNQyxRQUFRRCxTQUFTQyxLQUFLLENBQUM7SUFDN0IsSUFBSSxDQUFDQSxPQUFPLE9BQU87SUFFbkIsT0FBTztRQUNMQyxlQUFlQyxTQUFTRixLQUFLLENBQUMsRUFBRSxFQUFFO1FBQ2xDRyxZQUFZRCxTQUFTRixLQUFLLENBQUMsRUFBRSxFQUFFO0lBQ2pDO0FBQ0Y7QUFFQTs7OztDQUlDLEdBQ00sU0FBU0ksd0JBQXdCTCxRQUFnQjtJQUN0RCxNQUFNQyxRQUFRRCxTQUFTQyxLQUFLLENBQUM7SUFDN0IsSUFBSSxDQUFDQSxPQUFPLE9BQU87SUFFbkIsT0FBTztRQUNMQyxlQUFlQyxTQUFTRixLQUFLLENBQUMsRUFBRSxFQUFFO1FBQ2xDRyxZQUFZRCxTQUFTRixLQUFLLENBQUMsRUFBRSxFQUFFO0lBQ2pDO0FBQ0Y7QUFFQTs7Q0FFQyxHQUNNLFNBQVNLLHVCQUNkQyxVQUFvQixFQUNwQkMsZUFBeUI7UUFDekJDLFVBQUFBLGlFQUFrQjtJQUVsQiwrRkFBK0Y7SUFDL0YsTUFBTUMsY0FBYyxDQUFDQyxNQUFjWDtRQUNqQyxJQUFJLENBQUNXLFFBQVFBLFNBQVMsS0FBSztZQUN6QixPQUFPLElBQWEsT0FBVFg7UUFDYjtRQUNBLE1BQU1ZLFVBQVVELEtBQUtFLFFBQVEsQ0FBQyxPQUFPRixLQUFLRyxLQUFLLENBQUMsR0FBRyxDQUFDLEtBQUtIO1FBQ3pELE9BQU8sR0FBY1gsT0FBWFksU0FBUSxLQUFZLE9BQVRaO0lBQ3ZCO0lBQ0EsTUFBTWUsY0FBYyxJQUFJQztJQUV4QixzQkFBc0I7SUFDdEJULFdBQVdVLE9BQU8sQ0FBQ2pCLENBQUFBO1FBQ2pCLE1BQU1rQixTQUFTbkIsbUJBQW1CQztRQUNsQyxJQUFJLENBQUNr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Q3ZGLGVBQXVCRSxhQUN6QyxpQkFBd0NBLE9BQXZCRixlQUFjLFdBQW9CLE9BQVhFLFlBQVc7QUFDdkQsRUFBVyIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxicmFkeVxcRGVza3RvcFxcUG9ydGZvbGlvXFxoYWNrLXR4LW1hbmdhLW5hcnJhdGlvblxcZnJvbnRlbmRcXHV0aWxzXFxwYWdlQXVkaW9NYW5hZ2VyLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEZpbGU6IGZyb250ZW5kL3V0aWxzL3BhZ2VBdWRpb01hbmFnZXIudHNcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgUGFnZUF1ZGlvRGF0YSB7XHJcbiAgcGFnZU51bWJlcjogbnVtYmVyO1xyXG4gIGNoYXB0ZXJOdW1iZXI6IG51bWJlcjtcclxuICBhdWRpb1VybDogc3RyaW5nO1xyXG4gIHRyYW5zY3JpcHRVcmw6IHN0cmluZztcclxuICB0cmFuc2NyaXB0RGF0YT86IFRyYW5zY3JpcHRFbnRyeVtdO1xyXG4gIGR1cmF0aW9uPzogbnVtYmVyO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFRyYW5zY3JpcHRFbnRyeSB7XHJcbiAgaWQ6IHN0cmluZztcclxuICB0aW1lc3RhbXA6IG51bWJlcjtcclxuICBzcGVha2VyOiBzdHJpbmc7XHJcbiAgdGV4dDogc3RyaW5nO1xyXG4gIGlzQWN0aXZlPzogYm9vbGVhbjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBDaGFwdGVyQXVkaW9EYXRhIHtcclxuICBjaGFwdGVyTnVtYmVyOiBudW1iZXI7XHJcbiAgcGFnZXM6IFBhZ2VBdWRpb0RhdGFbXTtcclxuICB0b3RhbFBhZ2VzOiBudW1iZXI7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBQYXJzZXMgZmlsZW5hbWUgdG8gZXh0cmFjdCBjaGFwdGVyIGFuZCBwYWdlIGluZm9ybWF0aW9uXHJcbiAqIEV4cGVjdGVkIGZvcm1hdDogY2h7Y2hhcHRlcn1fcGFnZXtwYWdlfV9kaWFsb2d1ZV97dGltZXN0YW1wfS5tcDNcclxuICogRXhhbXBsZTogY2gwMV9wYWdlMDFfZGlhbG9ndWVfMjAyNTEwMThfMjIwNzE3Lm1wM1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlQXVkaW9GaWxlbmFtZShmaWxlbmFtZTogc3RyaW5nKTogeyBjaGFwdGVyTnVtYmVyOiBudW1iZXI7IHBhZ2VOdW1iZXI6IG51bWJlciB9IHwgbnVsbCB7XHJcbiAgY29uc3QgbWF0Y2ggPSBmaWxlbmFtZS5tYXRjaCgvY2goXFxkKylfcGFnZShcXGQrKV9kaWFsb2d1ZS8pO1xyXG4gIGlmICghbWF0Y2gpIHJldHVybiBudWxsO1xyXG4gIFxyXG4gIHJldHVybiB7XHJcbiAgICBjaGFwdGVyTnVtYmVyOiBwYXJzZUludChtYXRjaFsxXSwgMTApLFxyXG4gICAgcGFnZU51bWJlcjogcGFyc2VJbnQobWF0Y2hbMl0sIDEwKVxyXG4gIH07XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBQYXJzZXMgdHJhbnNjcmlwdCBmaWxlbmFtZSB0byBleHRyYWN0IGNoYXB0ZXIgYW5kIHBhZ2UgaW5mb3JtYXRpb25cclxuICogRXhwZWN0ZWQgZm9ybWF0OiBjaHtjaGFwdGVyfV9wYWdle3BhZ2V9X3RyYW5zY3JpcHRfe3RpbWVzdGFtcH0udHh0XHJcbiAqIEV4YW1wbGU6IGNoMDFfcGFnZTAxX3RyYW5zY3JpcHRfMjAyNTEwMThfMjIwNzE3LnR4dFxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlVHJhbnNjcmlwdEZpbGVuYW1lKGZpbGVuYW1lOiBzdHJpbmcpOiB7IGNoYXB0ZXJOdW1iZXI6IG51bWJlcjsgcGFnZU51bWJlcjogbnVtYmVyIH0gfCBudWxsIHtcclxuICBjb25zdCBtYXRjaCA9IGZpbGVuYW1lLm1hdGNoKC9jaChcXGQrKV9wYWdlKFxcZCspX3RyYW5zY3JpcHQvKTtcclxuICBpZiAoIW1hdGNoKSByZXR1cm4gbnVsbDtcclxuICBcclxuICByZXR1cm4ge1xyXG4gICAgY2hhcHRlck51bWJlcjogcGFyc2VJbnQobWF0Y2hbMV0sIDEwKSxcclxuICAgIHBhZ2VOdW1iZXI6IHBhcnNlSW50KG1hdGNoWzJdLCAxMClcclxuICB9O1xyXG59XHJcblxyXG4vKipcclxuICogR3JvdXBzIGF1ZGlvIGFuZCB0cmFuc2NyaXB0IGZpbGVzIGJ5IGNoYXB0ZXIgYW5kIHBhZ2VcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBvcmdhbml6ZVBhZ2VBdWRpb0ZpbGVzKFxyXG4gIGF1ZGlvRmlsZXM6IHN0cmluZ1tdLFxyXG4gIHRyYW5zY3JpcHRGaWxlczogc3RyaW5nW10sXHJcbiAgYmFzZVVybDogc3RyaW5nID0gJy9hc3NldHMnXHJcbik6IENoYXB0ZXJBdWRpb0RhdGFbXSB7XHJcbiAgLy8gRW5zdXJlIHdlIGpvaW4gYmFzZVVybCBhbmQgZmlsZW5hbWVzIHdpdGhvdXQgcHJvZHVjaW5nIHByb3RvY29sLXJlbGF0aXZlIFVSTHMgKGUuZy4sIC8vZmlsZSlcclxuICBjb25zdCBqb2luVXJsUGF0aCA9IChyb290OiBzdHJpbmcsIGZpbGVuYW1lOiBzdHJpbmcpOiBzdHJpbmcgPT4ge1xyXG4gICAgaWYgKCFyb290IHx8IHJvb3QgPT09ICcvJykge1xyXG4gICAgICByZXR1cm4gYC8ke2ZpbGVuYW1lfWA7XHJcbiAgICB9XHJcbiAgICBjb25zdCB0cmltbWVkID0gcm9vdC5lbmRzV2l0aCgnLycpID8gcm9vdC5zbGljZSgwLCAtMSkgOiByb290O1xyXG4gICAgcmV0dXJuIGAke3RyaW1tZWR9LyR7ZmlsZW5hbWV9YDtcclxuICB9O1xyXG4gIGNvbnN0IGNoYXB0ZXJzTWFwID0gbmV3IE1hcDxudW1iZXIsIE1hcDxudW1iZXIsIFBhZ2VBdWRpb0RhdGE+PigpO1xyXG4gIFxyXG4gIC8vIFByb2Nlc3MgYXVkaW8gZmlsZXNcclxuICBhdWRpb0ZpbGVzLmZvckVhY2goZmlsZW5hbWUgPT4ge1xyXG4gICAgY29uc3QgcGFyc2VkID0gcGFyc2VBdWRpb0ZpbGVuYW1lKGZpbGVuYW1lKTtcclxuICAgIGlmICghcGFyc2VkKSByZXR1cm47XHJcbiAgICBcclxuICAgIGNvbnN0IHsgY2hhcHRlck51bWJlciwgcGFnZU51bWJlciB9ID0gcGFyc2VkO1xyXG4gICAgXHJcbiAgICBpZiAoIWNoYXB0ZXJzTWFwLmhhcyhjaGFwdGVyTnVtYmVyKSkge1xyXG4gICAgICBjaGFwdGVyc01hcC5zZXQoY2hhcHRlck51bWJlciwgbmV3IE1hcCgpKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgY29uc3QgY2hhcHRlclBhZ2VzID0gY2hhcHRlcnNNYXAuZ2V0KGNoYXB0ZXJOdW1iZXIpITtcclxuICAgIGlmICghY2hhcHRlclBhZ2VzLmhhcyhwYWdlTnVtYmVyKSkge1xyXG4gICAgICBjaGFwdGVyUGFnZXMuc2V0KHBhZ2VOdW1iZXIsIHtcclxuICAgICAgICBwYWdlTnVtYmVyLFxyXG4gICAgICAgIGNoYXB0ZXJOdW1iZXIsXHJcbiAgICAgICAgYXVkaW9Vcmw6ICcnLFxyXG4gICAgICAgIHRyYW5zY3JpcHRVcmw6ICcnXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBjaGFwdGVyUGFnZXMuZ2V0KHBhZ2VOdW1iZXIpIS5hdWRpb1VybCA9IGpvaW5VcmxQYXRoKGJhc2VVcmwsIGZpbGVuYW1lKTtcclxuICB9KTtcclxuICBcclxuICAvLyBQcm9jZXNzIHRyYW5zY3JpcHQgZmlsZXNcclxuICB0cmFuc2NyaXB0RmlsZXMuZm9yRWFjaChmaWxlbmFtZSA9PiB7XHJcbiAgICBjb25zdCBwYXJzZWQgPSBwYXJzZVRyYW5zY3JpcHRGaWxlbmFtZShmaWxlbmFtZSk7XHJcbiAgICBpZiAoIXBhcnNlZCkgcmV0dXJuO1xyXG4gICAgXHJcbiAgICBjb25zdCB7IGNoYXB0ZXJOdW1iZXIsIHBhZ2VOdW1iZXIgfSA9IHBhcnNlZDtcclxuICAgIFxyXG4gICAgaWYgKCFjaGFwdGVyc01hcC5oYXMoY2hhcHRlck51bWJlcikpIHtcclxuICAgICAgY2hhcHRlcnNNYXAuc2V0KGNoYXB0ZXJOdW1iZXIsIG5ldyBNYXAoKSk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGNvbnN0IGNoYXB0ZXJQYWdlcyA9IGNoYXB0ZXJzTWFwLmdldChjaGFwdGVyTnVtYmVyKSE7XHJcbiAgICBpZiAoIWNoYXB0ZXJQYWdlcy5oYXMocGFnZU51bWJlcikpIHtcclxuICAgICAgY2hhcHRlclBhZ2VzLnNldChwYWdlTnVtYmVyLCB7XHJcbiAgICAgICAgcGFnZU51bWJlcixcclxuICAgICAgICBjaGFwdGVyTnVtYmVyLFxyXG4gICAgICAgIGF1ZGlvVXJsOiAnJyxcclxuICAgICAgICB0cmFuc2NyaXB0VXJsOiAnJ1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgY2hhcHRlclBhZ2VzLmdldChwYWdlTnVtYmVyKSEudHJhbnNjcmlwdFVybCA9IGpvaW5VcmxQYXRoKGJhc2VVcmwsIGZpbGVuYW1lKTtcclxuICB9KTtcclxuICBcclxuICAvLyBDb252ZXJ0IHRvIGFycmF5IGZvcm1hdFxyXG4gIGNvbnN0IGNoYXB0ZXJzOiBDaGFwdGVyQXVkaW9EYXRhW10gPSBbXTtcclxuICBjaGFwdGVyc01hcC5mb3JFYWNoKChwYWdlcywgY2hhcHRlck51bWJlcikgPT4ge1xyXG4gICAgY29uc3QgcGFnZUFycmF5ID0gQXJyYXkuZnJvbShwYWdlcy52YWx1ZXMoKSkuc29ydCgoYSwgYikgPT4gYS5wYWdlTnVtYmVyIC0gYi5wYWdlTnVtYmVyKTtcclxuICAgIGNoYXB0ZXJzLnB1c2goe1xyXG4gICAgICBjaGFwdGVyTnVtYmVyLFxyXG4gICAgICBwYWdlczogcGFnZUFycmF5LFxyXG4gICAgICB0b3RhbFBhZ2VzOiBwYWdlQXJyYXkubGVuZ3RoXHJcbiAgICB9KTtcclxuICB9KTtcclxuICBcclxuICBjb25zdCByZXN1bHQgPSBjaGFwdGVycy5zb3J0KChhLCBiKSA9PiBhLmNoYXB0ZXJOdW1iZXIgLSBiLmNoYXB0ZXJOdW1iZXIpO1xyXG4gIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBMb2FkcyB0cmFuc2NyaXB0IGRhdGEgZnJvbSBVUkxcclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBsb2FkVHJhbnNjcmlwdERhdGEodHJhbnNjcmlwdFVybDogc3RyaW5nKTogUHJvbWlzZTxUcmFuc2NyaXB0RW50cnlbXT4ge1xyXG4gIHRyeSB7XHJcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHRyYW5zY3JpcHRVcmwpO1xyXG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBsb2FkIHRyYW5zY3JpcHQ6ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgY29uc3QgY29udGVudCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcclxuICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlVHJhbnNjcmlwdENvbnRlbnQoY29udGVudCk7XHJcbiAgICByZXR1cm4gcGFyc2VkO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBsb2FkaW5nIHRyYW5zY3JpcHQ6JywgZXJyb3IpO1xyXG4gICAgcmV0dXJuIFtdO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIFBhcnNlcyB0cmFuc2NyaXB0IGNvbnRlbnQgaW50byBzdHJ1Y3R1cmVkIGVudHJpZXNcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiBwYXJzZVRyYW5zY3JpcHRDb250ZW50KGNvbnRlbnQ6IHN0cmluZyk6IFRyYW5zY3JpcHRFbnRyeVtdIHtcclxuICBjb25zdCBsaW5lcyA9IGNvbnRlbnQudHJpbSgpLnNwbGl0KCdcXG4nKTtcclxuICBjb25zdCBlbnRyaWVzOiBUcmFuc2NyaXB0RW50cnlbXSA9IFtdO1xyXG4gIFxyXG4gIGxpbmVzLmZvckVhY2goKGxpbmUsIGluZGV4KSA9PiB7XHJcbiAgICBjb25zdCBtYXRjaCA9IGxpbmUubWF0Y2goL14oXFxkezJ9OlxcZHsyfSlcXHMrKC4rPyk6XFxzKyguKykkLyk7XHJcbiAgICBpZiAobWF0Y2gpIHtcclxuICAgICAgY29uc3QgWywgdGltZVN0ciwgc3BlYWtlciwgdGV4dF0gPSBtYXRjaDtcclxuICAgICAgY29uc3QgW21pbnV0ZXMsIHNlY29uZHNdID0gdGltZVN0ci5zcGxpdCgnOicpLm1hcChOdW1iZXIpO1xyXG4gICAgICBjb25zdCB0aW1lc3RhbXAgPSBtaW51dGVzICogNjAgKyBzZWNvbmRzO1xyXG4gICAgICBcclxuICAgICAgZW50cmllcy5wdXNoKHtcclxuICAgICAgICBpZDogYGVudHJ5LSR7aW5kZXh9YCxcclxuICAgICAgICB0aW1lc3RhbXAsXHJcbiAgICAgICAgc3BlYWtlcjogc3BlYWtlci50cmltKCksXHJcbiAgICAgICAgdGV4dDogdGV4dC50cmltKCksXHJcbiAgICAgICAgaXNBY3RpdmU6IGZhbHNlXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH0pO1xyXG4gIFxyXG4gIHJldHVybiBlbnRyaWVzO1xyXG59XHJcblxyXG4vKipcclxuICogRmluZHMgdGhlIGFjdGl2ZSB0cmFuc2NyaXB0IGVudHJ5IGJhc2VkIG9uIGN1cnJlbnQgdGltZVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRBY3RpdmVUcmFuc2NyaXB0RW50cnkoXHJcbiAgZW50cmllczogVHJhbnNjcmlwdEVudHJ5W10sIFxyXG4gIGN1cnJlbnRUaW1lOiBudW1iZXJcclxuKTogVHJhbnNjcmlwdEVudHJ5IHwgbnVsbCB7XHJcbiAgbGV0IGFjdGl2ZUVudHJ5OiBUcmFuc2NyaXB0RW50cnkgfCBudWxsID0gbnVsbDtcclxuICBcclxuICBmb3IgKGxldCBpID0gMDsgaSA8IGVudHJpZXMubGVuZ3RoOyBpKyspIHtcclxuICAgIGNvbnN0IGVudHJ5ID0gZW50cmllc1tpXTtcclxuICAgIGNvbnN0IG5leHRFbnRyeSA9IGVudHJpZXNbaSArIDFdO1xyXG4gICAgXHJcbiAgICBpZiAoY3VycmVudFRpbWUgPj0gZW50cnkudGltZXN0YW1wICYmICghbmV4dEVudHJ5IHx8IGN1cnJlbnRUaW1lIDwgbmV4dEVudHJ5LnRpbWVzdGFtcCkpIHtcclxuICAgICAgYWN0aXZlRW50cnkgPSBlbnRyeTtcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgfVxyXG4gIFxyXG4gIHJldHVybiBhY3RpdmVFbnRyeTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFVwZGF0ZXMgYWN0aXZlIHN0YXRlIGZvciB0cmFuc2NyaXB0IGVudHJpZXNcclxuICovXHJcbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVUcmFuc2NyaXB0QWN0aXZlU3RhdGUoXHJcbiAgZW50cmllczogVHJhbnNjcmlwdEVudHJ5W10sIFxyXG4gIGN1cnJlbnRUaW1lOiBudW1iZXJcclxuKTogVHJhbnNjcmlwdEVudHJ5W10ge1xyXG4gIHJldHVybiBlbnRyaWVzLm1hcChlbnRyeSA9PiAoe1xyXG4gICAgLi4uZW50cnksXHJcbiAgICBpc0FjdGl2ZTogZW50cnkudGltZXN0YW1wIDw9IGN1cnJlbnRUaW1lICYmIFxyXG4gICAgICAgICAgICAgIChlbnRyaWVzLmZpbmQoZSA9PiBlLnRpbWVzdGFtcCA+IGVudHJ5LnRpbWVzdGFtcCk/LnRpbWVzdGFtcCB8fCBJbmZpbml0eSkgPiBjdXJyZW50VGltZVxyXG4gIH0pKTtcclxufVxyXG5cclxuLy8gQVBJIEludGVncmF0aW9uIEhlbHBlcnMgKGZvciBmdXR1cmUgU3VwYWJhc2UgaW50ZWdyYXRpb24pXHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFN1cGFiYXNlUGFnZUF1ZGlvRGF0YSB7XHJcbiAgaWQ6IHN0cmluZztcclxuICBjaGFwdGVyX251bWJlcjogbnVtYmVyO1xyXG4gIHBhZ2VfbnVtYmVyOiBudW1iZXI7XHJcbiAgYXVkaW9fdXJsOiBzdHJpbmc7XHJcbiAgdHJhbnNjcmlwdF91cmw6IHN0cmluZztcclxuICB0cmFuc2NyaXB0X2NvbnRlbnQ/OiBzdHJpbmc7XHJcbiAgZHVyYXRpb24/OiBudW1iZXI7XHJcbiAgY3JlYXRlZF9hdDogc3RyaW5nO1xyXG4gIHVwZGF0ZWRfYXQ6IHN0cmluZztcclxufVxyXG5cclxuLyoqXHJcbiAqIENvbnZlcnRzIFN1cGFiYXNlIGRhdGEgdG8gbG9jYWwgZm9ybWF0XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gY29udmVydFN1cGFiYXNlVG9Mb2NhbChzdXBhYmFzZURhdGE6IFN1cGFiYXNlUGFnZUF1ZGlvRGF0YVtdKTogQ2hhcHRlckF1ZGlvRGF0YVtdIHtcclxuICBjb25zdCBjaGFwdGVyc01hcCA9IG5ldyBNYXA8bnVtYmVyLCBNYXA8bnVtYmVyLCBQYWdlQXVkaW9EYXRhPj4oKTtcclxuICBcclxuICBzdXBhYmFzZURhdGEuZm9yRWFjaChpdGVtID0+IHtcclxuICAgIGlmICghY2hhcHRlcnNNYXAuaGFzKGl0ZW0uY2hhcHRlcl9udW1iZXIpKSB7XHJcbiAgICAgIGNoYXB0ZXJzTWFwLnNldChpdGVtLmNoYXB0ZXJfbnVtYmVyLCBuZXcgTWFwKCkpO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBjb25zdCBjaGFwdGVyUGFnZXMgPSBjaGFwdGVyc01hcC5nZXQoaXRlbS5jaGFwdGVyX251bWJlcikhO1xyXG4gICAgY2hhcHRlclBhZ2VzLnNldChpdGVtLnBhZ2VfbnVtYmVyLCB7XHJcbiAgICAgIHBhZ2VOdW1iZXI6IGl0ZW0ucGFnZV9udW1iZXIsXHJcbiAgICAgIGNoYXB0ZXJOdW1iZXI6IGl0ZW0uY2hhcHRlcl9udW1iZXIsXHJcbiAgICAgIGF1ZGlvVXJsOiBpdGVtLmF1ZGlvX3VybCxcclxuICAgICAgdHJhbnNjcmlwdFVybDogaXRlbS50cmFuc2NyaXB0X3VybCxcclxuICAgICAgdHJhbnNjcmlwdERhdGE6IGl0ZW0udHJhbnNjcmlwdF9jb250ZW50ID8gcGFyc2VUcmFuc2NyaXB0Q29udGVudChpdGVtLnRyYW5zY3JpcHRfY29udGVudCkgOiB1bmRlZmluZWQsXHJcbiAgICAgIGR1cmF0aW9uOiBpdGVtLmR1cmF0aW9uXHJcbiAgICB9KTtcclxuICB9KTtcclxuICBcclxuICBjb25zdCBjaGFwdGVyczogQ2hhcHRlckF1ZGlvRGF0YVtdID0gW107XHJcbiAgY2hhcHRlcnNNYXAuZm9yRWFjaCgocGFnZXMsIGNoYXB0ZXJOdW1iZXIpID0+IHtcclxuICAgIGNvbnN0IHBhZ2VBcnJheSA9IEFycmF5LmZyb20ocGFnZXMudmFsdWVzKCkpLnNvcnQoKGEsIGIpID0+IGEucGFnZU51bWJlciAtIGIucGFnZU51bWJlcik7XHJcbiAgICBjaGFwdGVycy5wdXNoKHtcclxuICAgICAgY2hhcHRlck51bWJlcixcclxuICAgICAgcGFnZXM6IHBhZ2VBcnJheSxcclxuICAgICAgdG90YWxQYWdlczogcGFnZUFycmF5Lmxlbmd0aFxyXG4gICAgfSk7XHJcbiAgfSk7XHJcbiAgXHJcbiAgcmV0dXJuIGNoYXB0ZXJzLnNvcnQoKGEsIGIpID0+IGEuY2hhcHRlck51bWJlciAtIGIuY2hhcHRlck51bWJlcik7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBBUEkgZW5kcG9pbnQgaGVscGVycyBmb3IgZnV0dXJlIGludGVncmF0aW9uXHJcbiAqL1xyXG5leHBvcnQgY29uc3QgQVBJX0VORFBPSU5UUyA9IHtcclxuICBHRVRfUEFHRV9BVURJTzogKGNoYXB0ZXJOdW1iZXI6IG51bWJlciwgcGFnZU51bWJlcjogbnVtYmVyKSA9PiBcclxuICAgIGAvYXBpL2NoYXB0ZXJzLyR7Y2hhcHRlck51bWJlcn0vcGFnZXMvJHtwYWdlTnVtYmVyfS9hdWRpb2AsXHJcbiAgR0VUX0NIQVBURVJfQVVESU86IChjaGFwdGVyTnVtYmVyOiBudW1iZXIpID0+IFxyXG4gICAgYC9hcGkvY2hhcHRlcnMvJHtjaGFwdGVyTnVtYmVyfS9hdWRpb2AsXHJcbiAgR0VUX1RSQU5TQ1JJUFQ6IChjaGFwdGVyTnVtYmVyOiBudW1iZXIsIHBhZ2VOdW1iZXI6IG51bWJlcikgPT4gXHJcbiAgICBgL2FwaS9jaGFwdGVycy8ke2NoYXB0ZXJOdW1iZXJ9L3BhZ2VzLyR7cGFnZU51bWJlcn0vdHJhbnNjcmlwdGAsXHJcbiAgVVBMT0FEX1BBR0VfQVVESU86IChjaGFwdGVyTnVtYmVyOiBudW1iZXIsIHBhZ2VOdW1iZXI6IG51bWJlcikgPT4gXHJcbiAgICBgL2FwaS9jaGFwdGVycy8ke2NoYXB0ZXJOdW1iZXJ9L3BhZ2VzLyR7cGFnZU51bWJlcn0vYXVkaW8vdXBsb2FkYFxyXG59IGFzIGNvbnN0O1xyXG4iXSwibmFtZXMiOlsicGFyc2VBdWRpb0ZpbGVuYW1lIiwiZmlsZW5hbWUiLCJtYXRjaCIsImNoYXB0ZXJOdW1iZXIiLCJwYXJzZUludCIsInBhZ2VOdW1iZXIiLCJwYXJzZVRyYW5zY3JpcHRGaWxlbmFtZSIsIm9yZ2FuaXplUGFnZUF1ZGlvRmlsZXMiLCJhdWRpb0ZpbGVzIiwidHJhbnNjcmlwdEZpbGVzIiwiYmFzZVVybCIsImpvaW5VcmxQYXRoIiwicm9vdCIsInRyaW1tZWQiLCJlbmRzV2l0aCIsInNsaWNlIiwiY2hhcHRlcnNNYXAiLCJNYXAiLCJmb3JFYWNoIiwicGFyc2VkIiwiaGFzIiwic2V0IiwiY2hhcHRlclBhZ2VzIiwiZ2V0IiwiYXVkaW9VcmwiLCJ0cmFuc2NyaXB0VXJsIiwiY2hhcHRlcnMiLCJwYWdlcyIsInBhZ2VBcnJheSIsIkFycmF5IiwiZnJvbSIsInZhbHVlcyIsInNvcnQiLCJhIiwiYiIsInB1c2giLCJ0b3RhbFBhZ2VzIiwibGVuZ3RoIiwicmVzdWx0IiwibG9hZFRyYW5zY3JpcHREYXRhIiwicmVzcG9uc2UiLCJmZXRjaCIsIm9rIiwiRXJyb3IiLCJzdGF0dXNUZXh0IiwiY29udGVudCIsInRleHQiLCJwYXJzZVRyYW5zY3JpcHRDb250ZW50IiwiZXJyb3IiLCJjb25zb2xlIiwibGluZXMiLCJ0cmltIiwic3BsaXQiLCJlbnRyaWVzIiwibGluZSIsImluZGV4IiwidGltZVN0ciIsInNwZWFrZXIiLCJtaW51dGVzIiwic2Vjb25kcyIsIm1hcCIsIk51bWJlciIsInRpbWVzdGFtcCIsImlkIiwiaXNBY3RpdmUiLCJmaW5kQWN0aXZlVHJhbnNjcmlwdEVudHJ5IiwiY3VycmVudFRpbWUiLCJhY3RpdmVFbnRyeSIsImkiLCJlbnRyeSIsIm5leHRFbnRyeSIsInVwZGF0ZVRyYW5zY3JpcHRBY3RpdmVTdGF0ZSIsImZpbmQiLCJlIiwiSW5maW5pdHkiLCJjb252ZXJ0U3VwYWJhc2VUb0xvY2FsIiwic3VwYWJhc2VEYXRhIiwiaXRlbSIsImNoYXB0ZXJfbnVtYmVyIiwicGFnZV9udW1iZXIiLCJhdWRpb191cmwiLCJ0cmFuc2NyaXB0X3VybCIsInRyYW5zY3JpcHREYXRhIiwidHJhbnNjcmlwdF9jb250ZW50IiwidW5kZWZpbmVkIiwiZHVyYXRpb24iLCJBUElfRU5EUE9JTlRTIiwiR0VUX1BBR0VfQVVESU8iLCJHRVRfQ0hBUFRFUl9BVURJTyIsIkdFVF9UUkFOU0NSSVBUIiwiVVBMT0FEX1BBR0VfQVVESU8iXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./utils/pageAudioManager.ts\n"));

/***/ })

});