"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./components/AudioPlayer.tsx":
/*!************************************!*\
  !*** ./components/AudioPlayer.tsx ***!
  \************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AudioPlayer: () => (/* binding */ AudioPlayer)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* __next_internal_client_entry_do_not_use__ AudioPlayer auto */ \nvar _s = $RefreshSig$();\n\nfunction AudioPlayer(param) {\n    let { audioUrl, isPlaying, volume, speed, isMuted, currentTime, onTimeUpdate, onDurationChange, onEnded, onError, onLoadStart, onCanPlay } = param;\n    _s();\n    const audioRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const previousUrlRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)('');\n    const lastSeekTimeRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(0);\n    const isSeekingRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    // Update audio properties when they change\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"AudioPlayer.useEffect\": ()=>{\n            const audio = audioRef.current;\n            if (!audio) return;\n            audio.volume = isMuted ? 0 : volume;\n            audio.playbackRate = speed;\n        }\n    }[\"AudioPlayer.useEffect\"], [\n        volume,\n        speed,\n        isMuted\n    ]);\n    // Handle seeking when currentTime changes externally\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"AudioPlayer.useEffect\": ()=>{\n            const audio = audioRef.current;\n            if (!audio) return;\n            // Only seek if the difference is significant (more than 0.5 seconds)\n            // This prevents stuttering during normal playback while allowing proper seeking\n            const timeDifference = Math.abs(audio.currentTime - currentTime);\n            if (timeDifference > 0.5) {\n                audio.currentTime = currentTime;\n            }\n        }\n    }[\"AudioPlayer.useEffect\"], [\n        currentTime\n    ]);\n    // Handle play/pause with readiness guard\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"AudioPlayer.useEffect\": ()=>{\n            const audio = audioRef.current;\n            if (!audio) return;\n            if (isPlaying) {\n                // If not ready, wait for canplay then attempt to play once\n                if (!audio.src) return;\n                const tryPlay = {\n                    \"AudioPlayer.useEffect.tryPlay\": ()=>{\n                        audio.play().catch({\n                            \"AudioPlayer.useEffect.tryPlay\": (error)=>{\n                                if (error.name === 'AbortError') {\n                                    console.log('Audio play was aborted (likely due to source change)');\n                                    return;\n                                }\n                                console.error('Error playing audio:', error);\n                                onError();\n                            }\n                        }[\"AudioPlayer.useEffect.tryPlay\"]);\n                    }\n                }[\"AudioPlayer.useEffect.tryPlay\"];\n                if (audio.readyState >= 2) {\n                    tryPlay();\n                } else {\n                    const onCanPlayOnce = {\n                        \"AudioPlayer.useEffect.onCanPlayOnce\": ()=>{\n                            audio.removeEventListener('canplay', onCanPlayOnce);\n                            tryPlay();\n                        }\n                    }[\"AudioPlayer.useEffect.onCanPlayOnce\"];\n                    audio.addEventListener('canplay', onCanPlayOnce);\n                }\n            } else {\n                audio.pause();\n            }\n        }\n    }[\"AudioPlayer.useEffect\"], [\n        isPlaying,\n        onError\n    ]);\n    // Set up event listeners\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"AudioPlayer.useEffect\": ()=>{\n            const audio = audioRef.current;\n            if (!audio) return;\n            const handleTimeUpdate = {\n                \"AudioPlayer.useEffect.handleTimeUpdate\": ()=>onTimeUpdate(audio.currentTime)\n            }[\"AudioPlayer.useEffect.handleTimeUpdate\"];\n            const handleLoadedMetadata = {\n                \"AudioPlayer.useEffect.handleLoadedMetadata\": ()=>onDurationChange(audio.duration)\n            }[\"AudioPlayer.useEffect.handleLoadedMetadata\"];\n            const handleEnded = {\n                \"AudioPlayer.useEffect.handleEnded\": ()=>onEnded()\n            }[\"AudioPlayer.useEffect.handleEnded\"];\n            const handleError = {\n                \"AudioPlayer.useEffect.handleError\": ()=>{\n                    // Prevent looping caused by rapid error -> play attempts\n                    audio.pause();\n                    onError();\n                }\n            }[\"AudioPlayer.useEffect.handleError\"];\n            const handleLoadStart = {\n                \"AudioPlayer.useEffect.handleLoadStart\": ()=>onLoadStart === null || onLoadStart === void 0 ? void 0 : onLoadStart()\n            }[\"AudioPlayer.useEffect.handleLoadStart\"];\n            const handleCanPlay = {\n                \"AudioPlayer.useEffect.handleCanPlay\": ()=>onCanPlay === null || onCanPlay === void 0 ? void 0 : onCanPlay()\n            }[\"AudioPlayer.useEffect.handleCanPlay\"];\n            audio.addEventListener('timeupdate', handleTimeUpdate);\n            audio.addEventListener('loadedmetadata', handleLoadedMetadata);\n            audio.addEventListener('ended', handleEnded);\n            audio.addEventListener('error', handleError);\n            audio.addEventListener('loadstart', handleLoadStart);\n            audio.addEventListener('canplay', handleCanPlay);\n            return ({\n                \"AudioPlayer.useEffect\": ()=>{\n                    audio.removeEventListener('timeupdate', handleTimeUpdate);\n                    audio.removeEventListener('loadedmetadata', handleLoadedMetadata);\n                    audio.removeEventListener('ended', handleEnded);\n                    audio.removeEventListener('error', handleError);\n                    audio.removeEventListener('loadstart', handleLoadStart);\n                    audio.removeEventListener('canplay', handleCanPlay);\n                }\n            })[\"AudioPlayer.useEffect\"];\n        }\n    }[\"AudioPlayer.useEffect\"], [\n        onTimeUpdate,\n        onDurationChange,\n        onEnded,\n        onError,\n        onLoadStart,\n        onCanPlay\n    ]);\n    // Update src when audioUrl changes and preserve playback settings\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"AudioPlayer.useEffect\": ()=>{\n            const audio = audioRef.current;\n            if (!audio) return;\n            // Only change source if the URL actually changed\n            if (audioUrl && audioUrl !== previousUrlRef.current) {\n                // Normalize relative URLs to root-relative\n                const normalizedUrl = audioUrl.startsWith('http') || audioUrl.startsWith('/') ? audioUrl : \"/\".concat(audioUrl);\n                // Pause current audio before changing source to prevent AbortError\n                audio.pause();\n                audio.src = normalizedUrl;\n                audio.load();\n                // Re-apply current playback settings after changing source\n                audio.playbackRate = speed;\n                audio.volume = isMuted ? 0 : volume;\n                previousUrlRef.current = normalizedUrl;\n                // If we should be playing, attempt to play or wait for readiness\n                if (isPlaying) {\n                    const tryPlay = {\n                        \"AudioPlayer.useEffect.tryPlay\": ()=>{\n                            audio.play().catch({\n                                \"AudioPlayer.useEffect.tryPlay\": (error)=>{\n                                    if (error.name === 'AbortError') {\n                                        console.log('Audio play was aborted (likely due to source change)');\n                                        return;\n                                    }\n                                    console.error('Error playing audio:', error);\n                                    onError();\n                                }\n                            }[\"AudioPlayer.useEffect.tryPlay\"]);\n                        }\n                    }[\"AudioPlayer.useEffect.tryPlay\"];\n                    if (audio.readyState >= 2) {\n                        tryPlay();\n                    } else {\n                        const onCanPlayOnce = {\n                            \"AudioPlayer.useEffect.onCanPlayOnce\": ()=>{\n                                audio.removeEventListener('canplay', onCanPlayOnce);\n                                tryPlay();\n                            }\n                        }[\"AudioPlayer.useEffect.onCanPlayOnce\"];\n                        audio.addEventListener('canplay', onCanPlayOnce);\n                    }\n                }\n            }\n        }\n    }[\"AudioPlayer.useEffect\"], [\n        audioUrl,\n        onError,\n        isPlaying,\n        speed,\n        volume,\n        isMuted\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"audio\", {\n        ref: audioRef,\n        preload: \"metadata\",\n        style: {\n            display: 'none'\n        },\n        children: previousUrlRef.current && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"source\", {\n            src: previousUrlRef.current,\n            type: \"audio/mpeg\"\n        }, void 0, false, {\n            fileName: \"C:\\\\Users\\\\brady\\\\Desktop\\\\Portfolio\\\\hack-tx-manga-narration\\\\frontend\\\\components\\\\AudioPlayer.tsx\",\n            lineNumber: 179,\n            columnNumber: 9\n        }, this)\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\brady\\\\Desktop\\\\Portfolio\\\\hack-tx-manga-narration\\\\frontend\\\\components\\\\AudioPlayer.tsx\",\n        lineNumber: 172,\n        columnNumber: 5\n    }, this);\n}\n_s(AudioPlayer, \"6NLItUtSbzO3H5d/NY9ogSpvFDo=\");\n_c = AudioPlayer;\nvar _c;\n$RefreshReg$(_c, \"AudioPlayer\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvQXVkaW9QbGF5ZXIudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUUwQztBQWlCbkMsU0FBU0UsWUFBWSxLQWFUO1FBYlMsRUFDMUJDLFFBQVEsRUFDUkMsU0FBUyxFQUNUQyxNQUFNLEVBQ05DLEtBQUssRUFDTEMsT0FBTyxFQUNQQyxXQUFXLEVBQ1hDLFlBQVksRUFDWkMsZ0JBQWdCLEVBQ2hCQyxPQUFPLEVBQ1BDLE9BQU8sRUFDUEMsV0FBVyxFQUNYQyxTQUFTLEVBQ1EsR0FiUzs7SUFjMUIsTUFBTUMsV0FBV2QsNkNBQU1BLENBQW1CO0lBQzFDLE1BQU1lLGlCQUFpQmYsNkNBQU1BLENBQVM7SUFDdEMsTUFBTWdCLGtCQUFrQmhCLDZDQUFNQSxDQUFTO0lBQ3ZDLE1BQU1pQixlQUFlakIsNkNBQU1BLENBQVU7SUFFckMsMkNBQTJDO0lBQzNDRCxnREFBU0E7aUNBQUM7WUFDUixNQUFNbUIsUUFBUUosU0FBU0ssT0FBTztZQUM5QixJQUFJLENBQUNELE9BQU87WUFFWkEsTUFBTWQsTUFBTSxHQUFHRSxVQUFVLElBQUlGO1lBQzdCYyxNQUFNRSxZQUFZLEdBQUdmO1FBQ3ZCO2dDQUFHO1FBQUNEO1FBQVFDO1FBQU9DO0tBQVE7SUFFM0IscURBQXFEO0lBQ3JEUCxnREFBU0E7aUNBQUM7WUFDUixNQUFNbUIsUUFBUUosU0FBU0ssT0FBTztZQUM5QixJQUFJLENBQUNELE9BQU87WUFFWixxRUFBcUU7WUFDckUsZ0ZBQWdGO1lBQ2hGLE1BQU1HLGlCQUFpQkMsS0FBS0MsR0FBRyxDQUFDTCxNQUFNWCxXQUFXLEdBQUdBO1lBQ3BELElBQUljLGlCQUFpQixLQUFLO2dCQUN4QkgsTUFBTVgsV0FBVyxHQUFHQTtZQUN0QjtRQUNGO2dDQUFHO1FBQUNBO0tBQVk7SUFFaEIseUNBQXlDO0lBQ3pDUixnREFBU0E7aUNBQUM7WUFDUixNQUFNbUIsUUFBUUosU0FBU0ssT0FBTztZQUM5QixJQUFJLENBQUNELE9B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O2lFQUFDLENBQUNDO29DQUNsQixJQUFJQSxNQUFNQyxJQUFJLEtBQUssY0FBYzt3Q0FDL0JDLFFBQVFDLEdBQUcsQ0FBQzt3Q0FDWjtvQ0FDRjtvQ0FDQUQsUUFBUUYsS0FBSyxDQUFDLHdCQUF3QkE7b0NBQ3RDakI7Z0NBQ0Y7O3dCQUNGOztvQkFDQSxJQUFJTyxNQUFNYyxVQUFVLElBQUksR0FBRzt3QkFDekJQO29CQUNGLE9BQU87d0JBQ0wsTUFBTVE7bUVBQWdCO2dDQUNwQmYsTUFBTWdCLG1CQUFtQixDQUFDLFdBQVdEO2dDQUNyQ1I7NEJBQ0Y7O3dCQUNBUCxNQUFNaUIsZ0JBQWdCLENBQUMsV0FBV0Y7b0JBQ3BDO2dCQUNGO1lBQ0Y7UUFDRjtnQ0FBRztRQUFDL0I7UUFBVVM7UUFBU1I7UUFBV0U7UUFBT0Q7UUFBUUU7S0FBUTtJQUV6RCxxQkFDRSw4REFBQ1k7UUFDQzZCLEtBQUtqQztRQUNMa0MsU0FBUTtRQUNSQyxPQUFPO1lBQUVDLFNBQVM7UUFBTztrQkFHeEJuQyxlQUFlSSxPQUFPLGtCQUNyQiw4REFBQ2dDO1lBQU8zQixLQUFLVCxlQUFlSSxPQUFPO1lBQUVpQyxNQUFLOzs7Ozs7Ozs7OztBQUlsRDtHQW5LZ0JuRDtLQUFBQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxicmFkeVxcRGVza3RvcFxcUG9ydGZvbGlvXFxoYWNrLXR4LW1hbmdhLW5hcnJhdGlvblxcZnJvbnRlbmRcXGNvbXBvbmVudHNcXEF1ZGlvUGxheWVyLnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCdcclxuXHJcbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmIH0gZnJvbSAncmVhY3QnO1xyXG5cclxuaW50ZXJmYWNlIEF1ZGlvUGxheWVyUHJvcHMge1xyXG4gIGF1ZGlvVXJsOiBzdHJpbmc7XHJcbiAgaXNQbGF5aW5nOiBib29sZWFuO1xyXG4gIHZvbHVtZTogbnVtYmVyO1xyXG4gIHNwZWVkOiBudW1iZXI7XHJcbiAgaXNNdXRlZDogYm9vbGVhbjtcclxuICBjdXJyZW50VGltZTogbnVtYmVyO1xyXG4gIG9uVGltZVVwZGF0ZTogKGN1cnJlbnRUaW1lOiBudW1iZXIpID0+IHZvaWQ7XHJcbiAgb25EdXJhdGlvbkNoYW5nZTogKGR1cmF0aW9uOiBudW1iZXIpID0+IHZvaWQ7XHJcbiAgb25FbmRlZDogKCkgPT4gdm9pZDtcclxuICBvbkVycm9yOiAoKSA9PiB2b2lkO1xyXG4gIG9uTG9hZFN0YXJ0PzogKCkgPT4gdm9pZDtcclxuICBvbkNhblBsYXk/OiAoKSA9PiB2b2lkO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gQXVkaW9QbGF5ZXIoeyBcclxuICBhdWRpb1VybCwgXHJcbiAgaXNQbGF5aW5nLCBcclxuICB2b2x1bWUsIFxyXG4gIHNwZWVkLCBcclxuICBpc011dGVkLFxyXG4gIGN1cnJlbnRUaW1lLFxyXG4gIG9uVGltZVVwZGF0ZSxcclxuICBvbkR1cmF0aW9uQ2hhbmdlLFxyXG4gIG9uRW5kZWQsXHJcbiAgb25FcnJvcixcclxuICBvbkxvYWRTdGFydCxcclxuICBvbkNhblBsYXlcclxufTogQXVkaW9QbGF5ZXJQcm9wcykge1xyXG4gIGNvbnN0IGF1ZGlvUmVmID0gdXNlUmVmPEhUTUxBdWRpb0VsZW1lbnQ+KG51bGwpO1xyXG4gIGNvbnN0IHByZXZpb3VzVXJsUmVmID0gdXNlUmVmPHN0cmluZz4oJycpO1xyXG4gIGNvbnN0IGxhc3RTZWVrVGltZVJlZiA9IHVzZVJlZjxudW1iZXI+KDApO1xyXG4gIGNvbnN0IGlzU2Vla2luZ1JlZiA9IHVzZVJlZjxib29sZWFuPihmYWxzZSk7XHJcblxyXG4gIC8vIFVwZGF0ZSBhdWRpbyBwcm9wZXJ0aWVzIHdoZW4gdGhleSBjaGFuZ2VcclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgY29uc3QgYXVkaW8gPSBhdWRpb1JlZi5jdXJyZW50O1xyXG4gICAgaWYgKCFhdWRpbykgcmV0dXJuO1xyXG5cclxuICAgIGF1ZGlvLnZvbHVtZSA9IGlzTXV0ZWQgPyAwIDogdm9sdW1lO1xyXG4gICAgYXVkaW8ucGxheWJhY2tSYXRlID0gc3BlZWQ7XHJcbiAgfSwgW3ZvbHVtZSwgc3BlZWQsIGlzTXV0ZWRdKTtcclxuXHJcbiAgLy8gSGFuZGxlIHNlZWtpbmcgd2hlbiBjdXJyZW50VGltZSBjaGFuZ2VzIGV4dGVybmFsbHlcclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgY29uc3QgYXVkaW8gPSBhdWRpb1JlZi5jdXJyZW50O1xyXG4gICAgaWYgKCFhdWRpbykgcmV0dXJuO1xyXG5cclxuICAgIC8vIE9ubHkgc2VlayBpZiB0aGUgZGlmZmVyZW5jZSBpcyBzaWduaWZpY2FudCAobW9yZSB0aGFuIDAuNSBzZWNvbmRzKVxyXG4gICAgLy8gVGhpcyBwcmV2ZW50cyBzdHV0dGVyaW5nIGR1cmluZyBub3JtYWwgcGxheWJhY2sgd2hpbGUgYWxsb3dpbmcgcHJvcGVyIHNlZWtpbmdcclxuICAgIGNvbnN0IHRpbWVEaWZmZXJlbmNlID0gTWF0aC5hYnMoYXVkaW8uY3VycmVudFRpbWUgLSBjdXJyZW50VGltZSk7XHJcbiAgICBpZiAodGltZURpZmZlcmVuY2UgPiAwLjUpIHtcclxuICAgICAgYXVkaW8uY3VycmVudFRpbWUgPSBjdXJyZW50VGltZTtcclxuICAgIH1cclxuICB9LCBbY3VycmVudFRpbWVdKTtcclxuXHJcbiAgLy8gSGFuZGxlIHBsYXkvcGF1c2Ugd2l0aCByZWFkaW5lc3MgZ3VhcmRcclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgY29uc3QgYXVkaW8gPSBhdWRpb1JlZi5jdXJyZW50O1xyXG4gICAgaWYgKCFhdWRpbykgcmV0dXJuO1xyXG5cclxuICAgIGlmIChpc1BsYXlpbmcpIHtcclxuICAgICAgLy8gSWYgbm90IHJlYWR5LCB3YWl0IGZvciBjYW5wbGF5IHRoZW4gYXR0ZW1wdCB0byBwbGF5IG9uY2VcclxuICAgICAgaWYgKCFhdWRpby5zcmMpIHJldHVybjtcclxuICAgICAgY29uc3QgdHJ5UGxheSA9ICgpID0+IHtcclxuICAgICAgICBhdWRpby5wbGF5KCkuY2F0Y2goKGVycm9yKSA9PiB7XHJcbiAgICAgICAgICBpZiAoZXJyb3IubmFtZSA9PT0gJ0Fib3J0RXJyb3InKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdBdWRpbyBwbGF5IHdhcyBhYm9ydGVkIChsaWtlbHkgZHVlIHRvIHNvdXJjZSBjaGFuZ2UpJyk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHBsYXlpbmcgYXVkaW86JywgZXJyb3IpO1xyXG4gICAgICAgICAgb25FcnJvcigpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgaWYgKGF1ZGlvLnJlYWR5U3RhdGUgPj0gMikge1xyXG4gICAgICAgIHRyeVBsYXkoKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjb25zdCBvbkNhblBsYXlPbmNlID0gKCkgPT4ge1xyXG4gICAgICAgICAgYXVkaW8ucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2FucGxheScsIG9uQ2FuUGxheU9uY2UpO1xyXG4gICAgICAgICAgdHJ5UGxheSgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgYXVkaW8uYWRkRXZlbnRMaXN0ZW5lcignY2FucGxheScsIG9uQ2FuUGxheU9uY2UpO1xyXG4gICAgICB9XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBhdWRpby5wYXVzZSgpO1xyXG4gICAgfVxyXG4gIH0sIFtpc1BsYXlpbmcsIG9uRXJyb3JdKTtcclxuXHJcbiAgLy8gU2V0IHVwIGV2ZW50IGxpc3RlbmVyc1xyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBjb25zdCBhdWRpbyA9IGF1ZGlvUmVmLmN1cnJlbnQ7XHJcbiAgICBpZiAoIWF1ZGlvKSByZXR1cm47XHJcblxyXG4gICAgY29uc3QgaGFuZGxlVGltZVVwZGF0ZSA9ICgpID0+IG9uVGltZVVwZGF0ZShhdWRpby5jdXJyZW50VGltZSk7XHJcbiAgICBjb25zdCBoYW5kbGVMb2FkZWRNZXRhZGF0YSA9ICgpID0+IG9uRHVyYXRpb25DaGFuZ2UoYXVkaW8uZHVyYXRpb24pO1xyXG4gICAgY29uc3QgaGFuZGxlRW5kZWQgPSAoKSA9PiBvbkVuZGVkKCk7XHJcbiAgICBjb25zdCBoYW5kbGVFcnJvciA9ICgpID0+IHtcclxuICAgICAgLy8gUHJldmVudCBsb29waW5nIGNhdXNlZCBieSByYXBpZCBlcnJvciAtPiBwbGF5IGF0dGVtcHRzXHJcbiAgICAgIGF1ZGlvLnBhdXNlKCk7XHJcbiAgICAgIG9uRXJyb3IoKTtcclxuICAgIH07XHJcbiAgICBjb25zdCBoYW5kbGVMb2FkU3RhcnQgPSAoKSA9PiBvbkxvYWRTdGFydD8uKCk7XHJcbiAgICBjb25zdCBoYW5kbGVDYW5QbGF5ID0gKCkgPT4gb25DYW5QbGF5Py4oKTtcclxuXHJcbiAgICBhdWRpby5hZGRFdmVudExpc3RlbmVyKCd0aW1ldXBkYXRlJywgaGFuZGxlVGltZVVwZGF0ZSk7XHJcbiAgICBhdWRpby5hZGRFdmVudExpc3RlbmVyKCdsb2FkZWRtZXRhZGF0YScsIGhhbmRsZUxvYWRlZE1ldGFkYXRhKTtcclxuICAgIGF1ZGlvLmFkZEV2ZW50TGlzdGVuZXIoJ2VuZGVkJywgaGFuZGxlRW5kZWQpO1xyXG4gICAgYXVkaW8uYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBoYW5kbGVFcnJvcik7XHJcbiAgICBhdWRpby5hZGRFdmVudExpc3RlbmVyKCdsb2Fkc3RhcnQnLCBoYW5kbGVMb2FkU3RhcnQpO1xyXG4gICAgYXVkaW8uYWRkRXZlbnRMaXN0ZW5lcignY2FucGxheScsIGhhbmRsZUNhblBsYXkpO1xyXG5cclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgIGF1ZGlvLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RpbWV1cGRhdGUnLCBoYW5kbGVUaW1lVXBkYXRlKTtcclxuICAgICAgYXVkaW8ucmVtb3ZlRXZlbnRMaXN0ZW5lcignbG9hZGVkbWV0YWRhdGEnLCBoYW5kbGVMb2FkZWRNZXRhZGF0YSk7XHJcbiAgICAgIGF1ZGlvLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2VuZGVkJywgaGFuZGxlRW5kZWQpO1xyXG4gICAgICBhdWRpby5yZW1vdmVFdmVudExpc3RlbmVyKCdlcnJvcicsIGhhbmRsZUVycm9yKTtcclxuICAgICAgYXVkaW8ucmVtb3ZlRXZlbnRMaXN0ZW5lcignbG9hZHN0YXJ0JywgaGFuZGxlTG9hZFN0YXJ0KTtcclxuICAgICAgYXVkaW8ucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2FucGxheScsIGhhbmRsZUNhblBsYXkpO1xyXG4gICAgfTtcclxuICB9LCBbb25UaW1lVXBkYXRlLCBvbkR1cmF0aW9uQ2hhbmdlLCBvbkVuZGVkLCBvbkVycm9yLCBvbkxvYWRTdGFydCwgb25DYW5QbGF5XSk7XHJcblxyXG4gIC8vIFVwZGF0ZSBzcmMgd2hlbiBhdWRpb1VybCBjaGFuZ2VzIGFuZCBwcmVzZXJ2ZSBwbGF5YmFjayBzZXR0aW5nc1xyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBjb25zdCBhdWRpbyA9IGF1ZGlvUmVmLmN1cnJlbnQ7XHJcbiAgICBpZiAoIWF1ZGlvKSByZXR1cm47XHJcblxyXG4gICAgLy8gT25seSBjaGFuZ2Ugc291cmNlIGlmIHRoZSBVUkwgYWN0dWFsbHkgY2hhbmdlZFxyXG4gICAgaWYgKGF1ZGlvVXJsICYmIGF1ZGlvVXJsICE9PSBwcmV2aW91c1VybFJlZi5jdXJyZW50KSB7XHJcbiAgICAgIC8vIE5vcm1hbGl6ZSByZWxhdGl2ZSBVUkxzIHRvIHJvb3QtcmVsYXRpdmVcclxuICAgICAgY29uc3Qgbm9ybWFsaXplZFVybCA9IChhdWRpb1VybC5zdGFydHNXaXRoKCdodHRwJykgfHwgYXVkaW9Vcmwuc3RhcnRzV2l0aCgnLycpKVxyXG4gICAgICAgID8gYXVkaW9VcmxcclxuICAgICAgICA6IGAvJHthdWRpb1VybH1gO1xyXG4gICAgICAvLyBQYXVzZSBjdXJyZW50IGF1ZGlvIGJlZm9yZSBjaGFuZ2luZyBzb3VyY2UgdG8gcHJldmVudCBBYm9ydEVycm9yXHJcbiAgICAgIGF1ZGlvLnBhdXNlKCk7XHJcbiAgICAgIGF1ZGlvLnNyYyA9IG5vcm1hbGl6ZWRVcmw7XHJcbiAgICAgIGF1ZGlvLmxvYWQoKTtcclxuICAgICAgLy8gUmUtYXBwbHkgY3VycmVudCBwbGF5YmFjayBzZXR0aW5ncyBhZnRlciBjaGFuZ2luZyBzb3VyY2VcclxuICAgICAgYXVkaW8ucGxheWJhY2tSYXRlID0gc3BlZWQ7XHJcbiAgICAgIGF1ZGlvLnZvbHVtZSA9IGlzTXV0ZWQgPyAwIDogdm9sdW1lO1xyXG4gICAgICBwcmV2aW91c1VybFJlZi5jdXJyZW50ID0gbm9ybWFsaXplZFVybDtcclxuICAgICAgLy8gSWYgd2Ugc2hvdWxkIGJlIHBsYXlpbmcsIGF0dGVtcHQgdG8gcGxheSBvciB3YWl0IGZvciByZWFkaW5lc3NcclxuICAgICAgaWYgKGlzUGxheWluZykge1xyXG4gICAgICAgIGNvbnN0IHRyeVBsYXkgPSAoKSA9PiB7XHJcbiAgICAgICAgICBhdWRpby5wbGF5KCkuY2F0Y2goKGVycm9yKSA9PiB7XHJcbiAgICAgICAgICAgIGlmIChlcnJvci5uYW1lID09PSAnQWJvcnRFcnJvcicpIHtcclxuICAgICAgICAgICAgICBjb25zb2xlLmxvZygnQXVkaW8gcGxheSB3YXMgYWJvcnRlZCAobGlrZWx5IGR1ZSB0byBzb3VyY2UgY2hhbmdlKScpO1xyXG4gICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBwbGF5aW5nIGF1ZGlvOicsIGVycm9yKTtcclxuICAgICAgICAgICAgb25FcnJvcigpO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAoYXVkaW8ucmVhZHlTdGF0ZSA+PSAyKSB7XHJcbiAgICAgICAgICB0cnlQbGF5KCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGNvbnN0IG9uQ2FuUGxheU9uY2UgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIGF1ZGlvLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NhbnBsYXknLCBvbkNhblBsYXlPbmNlKTtcclxuICAgICAgICAgICAgdHJ5UGxheSgpO1xyXG4gICAgICAgICAgfTtcclxuICAgICAgICAgIGF1ZGlvLmFkZEV2ZW50TGlzdGVuZXIoJ2NhbnBsYXknLCBvbkNhblBsYXlPbmNlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9LCBbYXVkaW9VcmwsIG9uRXJyb3IsIGlzUGxheWluZywgc3BlZWQsIHZvbHVtZSwgaXNNdXRlZF0pO1xyXG5cclxuICByZXR1cm4gKFxyXG4gICAgPGF1ZGlvXHJcbiAgICAgIHJlZj17YXVkaW9SZWZ9XHJcbiAgICAgIHByZWxvYWQ9XCJtZXRhZGF0YVwiXHJcbiAgICAgIHN0eWxlPXt7IGRpc3BsYXk6ICdub25lJyB9fVxyXG4gICAgPlxyXG4gICAgICB7LyogUHJvdmlkZSBhIHNvdXJjZSBlbGVtZW50IHdpdGggdHlwZSB0byBoZWxwIGJyb3dzZXIgcmVjb2duaXplIGZvcm1hdCAqL31cclxuICAgICAge3ByZXZpb3VzVXJsUmVmLmN1cnJlbnQgJiYgKFxyXG4gICAgICAgIDxzb3VyY2Ugc3JjPXtwcmV2aW91c1VybFJlZi5jdXJyZW50fSB0eXBlPVwiYXVkaW8vbXBlZ1wiIC8+XHJcbiAgICAgICl9XHJcbiAgICA8L2F1ZGlvPlxyXG4gICk7XHJcbn1cclxuIl0sIm5hbWVzIjpbInVzZUVmZmVjdCIsInVzZVJlZiIsIkF1ZGlvUGxheWVyIiwiYXVkaW9VcmwiLCJpc1BsYXlpbmciLCJ2b2x1bWUiLCJzcGVlZCIsImlzTXV0ZWQiLCJjdXJyZW50VGltZSIsIm9uVGltZVVwZGF0ZSIsIm9uRHVyYXRpb25DaGFuZ2UiLCJvbkVuZGVkIiwib25FcnJvciIsIm9uTG9hZFN0YXJ0Iiwib25DYW5QbGF5IiwiYXVkaW9SZWYiLCJwcmV2aW91c1VybFJlZiIsImxhc3RTZWVrVGltZVJlZiIsImlzU2Vla2luZ1JlZiIsImF1ZGlvIiwiY3VycmVudCIsInBsYXliYWNrUmF0ZSIsInRpbWVEaWZmZXJlbmNlIiwiTWF0aCIsImFicyIsInNyYyIsInRyeVBsYXkiLCJwbGF5IiwiY2F0Y2giLCJlcnJvciIsIm5hbWUiLCJjb25zb2xlIiwibG9nIiwicmVhZHlTdGF0ZSIsIm9uQ2FuUGxheU9uY2UiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiYWRkRXZlbnRMaXN0ZW5lciIsInBhdXNlIiwiaGFuZGxlVGltZVVwZGF0ZSIsImhhbmRsZUxvYWRlZE1ldGFkYXRhIiwiZHVyYXRpb24iLCJoYW5kbGVFbmRlZCIsImhhbmRsZUVycm9yIiwiaGFuZGxlTG9hZFN0YXJ0IiwiaGFuZGxlQ2FuUGxheSIsIm5vcm1hbGl6ZWRVcmwiLCJzdGFydHNXaXRoIiwibG9hZCIsInJlZiIsInByZWxvYWQiLCJzdHlsZSIsImRpc3BsYXkiLCJzb3VyY2UiLCJ0eXBlIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/AudioPlayer.tsx\n"));

/***/ })

});