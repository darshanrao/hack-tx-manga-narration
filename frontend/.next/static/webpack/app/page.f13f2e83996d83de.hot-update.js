"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./components/AudioPlayer.tsx":
/*!************************************!*\
  !*** ./components/AudioPlayer.tsx ***!
  \************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AudioPlayer: () => (/* binding */ AudioPlayer)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* __next_internal_client_entry_do_not_use__ AudioPlayer auto */ \nvar _s = $RefreshSig$();\n\nfunction AudioPlayer(param) {\n    let { audioUrl, isPlaying, volume, speed, isMuted, currentTime, onTimeUpdate, onDurationChange, onEnded, onError, onLoadStart, onCanPlay } = param;\n    _s();\n    const audioRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const previousUrlRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)('');\n    const lastSeekTimeRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(0);\n    const isSeekingRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    // Update audio properties when they change\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"AudioPlayer.useEffect\": ()=>{\n            const audio = audioRef.current;\n            if (!audio) return;\n            audio.volume = isMuted ? 0 : volume;\n            audio.playbackRate = speed;\n        }\n    }[\"AudioPlayer.useEffect\"], [\n        volume,\n        speed,\n        isMuted\n    ]);\n    // Handle seeking when currentTime changes externally\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"AudioPlayer.useEffect\": ()=>{\n            const audio = audioRef.current;\n            if (!audio) return;\n            // Only seek if the difference is significant (more than 0.5 seconds)\n            // This prevents stuttering during normal playback while allowing proper seeking\n            const timeDifference = Math.abs(audio.currentTime - currentTime);\n            if (timeDifference > 0.5) {\n                audio.currentTime = currentTime;\n            }\n        }\n    }[\"AudioPlayer.useEffect\"], [\n        currentTime\n    ]);\n    // Handle play/pause with readiness guard\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"AudioPlayer.useEffect\": ()=>{\n            const audio = audioRef.current;\n            if (!audio) return;\n            if (isPlaying) {\n                // If not ready, wait for canplay then attempt to play once\n                if (!audio.src) return;\n                const tryPlay = {\n                    \"AudioPlayer.useEffect.tryPlay\": ()=>{\n                        audio.play().catch({\n                            \"AudioPlayer.useEffect.tryPlay\": (error)=>{\n                                if (error.name === 'AbortError') {\n                                    console.log('Audio play was aborted (likely due to source change)');\n                                    return;\n                                }\n                                console.error('Error playing audio:', error);\n                                onError();\n                            }\n                        }[\"AudioPlayer.useEffect.tryPlay\"]);\n                    }\n                }[\"AudioPlayer.useEffect.tryPlay\"];\n                if (audio.readyState >= 2) {\n                    tryPlay();\n                } else {\n                    const onCanPlayOnce = {\n                        \"AudioPlayer.useEffect.onCanPlayOnce\": ()=>{\n                            audio.removeEventListener('canplay', onCanPlayOnce);\n                            tryPlay();\n                        }\n                    }[\"AudioPlayer.useEffect.onCanPlayOnce\"];\n                    audio.addEventListener('canplay', onCanPlayOnce);\n                }\n            } else {\n                audio.pause();\n            }\n        }\n    }[\"AudioPlayer.useEffect\"], [\n        isPlaying,\n        onError\n    ]);\n    // Set up event listeners\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"AudioPlayer.useEffect\": ()=>{\n            const audio = audioRef.current;\n            if (!audio) return;\n            const handleTimeUpdate = {\n                \"AudioPlayer.useEffect.handleTimeUpdate\": ()=>onTimeUpdate(audio.currentTime)\n            }[\"AudioPlayer.useEffect.handleTimeUpdate\"];\n            const handleLoadedMetadata = {\n                \"AudioPlayer.useEffect.handleLoadedMetadata\": ()=>onDurationChange(audio.duration)\n            }[\"AudioPlayer.useEffect.handleLoadedMetadata\"];\n            const handleEnded = {\n                \"AudioPlayer.useEffect.handleEnded\": ()=>onEnded()\n            }[\"AudioPlayer.useEffect.handleEnded\"];\n            const handleError = {\n                \"AudioPlayer.useEffect.handleError\": ()=>{\n                    // Prevent looping caused by rapid error -> play attempts\n                    audio.pause();\n                    onError();\n                }\n            }[\"AudioPlayer.useEffect.handleError\"];\n            const handleLoadStart = {\n                \"AudioPlayer.useEffect.handleLoadStart\": ()=>onLoadStart === null || onLoadStart === void 0 ? void 0 : onLoadStart()\n            }[\"AudioPlayer.useEffect.handleLoadStart\"];\n            const handleCanPlay = {\n                \"AudioPlayer.useEffect.handleCanPlay\": ()=>onCanPlay === null || onCanPlay === void 0 ? void 0 : onCanPlay()\n            }[\"AudioPlayer.useEffect.handleCanPlay\"];\n            audio.addEventListener('timeupdate', handleTimeUpdate);\n            audio.addEventListener('loadedmetadata', handleLoadedMetadata);\n            audio.addEventListener('ended', handleEnded);\n            audio.addEventListener('error', handleError);\n            audio.addEventListener('loadstart', handleLoadStart);\n            audio.addEventListener('canplay', handleCanPlay);\n            return ({\n                \"AudioPlayer.useEffect\": ()=>{\n                    audio.removeEventListener('timeupdate', handleTimeUpdate);\n                    audio.removeEventListener('loadedmetadata', handleLoadedMetadata);\n                    audio.removeEventListener('ended', handleEnded);\n                    audio.removeEventListener('error', handleError);\n                    audio.removeEventListener('loadstart', handleLoadStart);\n                    audio.removeEventListener('canplay', handleCanPlay);\n                }\n            })[\"AudioPlayer.useEffect\"];\n        }\n    }[\"AudioPlayer.useEffect\"], [\n        onTimeUpdate,\n        onDurationChange,\n        onEnded,\n        onError,\n        onLoadStart,\n        onCanPlay\n    ]);\n    // Update src when audioUrl changes\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"AudioPlayer.useEffect\": ()=>{\n            const audio = audioRef.current;\n            if (!audio) return;\n            // Only change source if the URL actually changed\n            if (audioUrl && audioUrl !== previousUrlRef.current) {\n                // Normalize relative URLs to root-relative\n                const normalizedUrl = audioUrl.startsWith('http') || audioUrl.startsWith('/') ? audioUrl : \"/\".concat(audioUrl);\n                // Pause current audio before changing source to prevent AbortError\n                audio.pause();\n                audio.src = normalizedUrl;\n                audio.load();\n                previousUrlRef.current = normalizedUrl;\n            }\n        }\n    }[\"AudioPlayer.useEffect\"], [\n        audioUrl,\n        onError\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"audio\", {\n        ref: audioRef,\n        preload: \"metadata\",\n        style: {\n            display: 'none'\n        },\n        children: previousUrlRef.current && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"source\", {\n            src: previousUrlRef.current,\n            type: \"audio/mpeg\"\n        }, void 0, false, {\n            fileName: \"C:\\\\Users\\\\brady\\\\Desktop\\\\Portfolio\\\\hack-tx-manga-narration\\\\frontend\\\\components\\\\AudioPlayer.tsx\",\n            lineNumber: 154,\n            columnNumber: 9\n        }, this)\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\brady\\\\Desktop\\\\Portfolio\\\\hack-tx-manga-narration\\\\frontend\\\\components\\\\AudioPlayer.tsx\",\n        lineNumber: 147,\n        columnNumber: 5\n    }, this);\n}\n_s(AudioPlayer, \"6NLItUtSbzO3H5d/NY9ogSpvFDo=\");\n_c = AudioPlayer;\nvar _c;\n$RefreshReg$(_c, \"AudioPlayer\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvQXVkaW9QbGF5ZXIudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUUwQztBQWlCbkMsU0FBU0UsWUFBWSxLQWFUO1FBYlMsRUFDMUJDLFFBQVEsRUFDUkMsU0FBUyxFQUNUQyxNQUFNLEVBQ05DLEtBQUssRUFDTEMsT0FBTyxFQUNQQyxXQUFXLEVBQ1hDLFlBQVksRUFDWkMsZ0JBQWdCLEVBQ2hCQyxPQUFPLEVBQ1BDLE9BQU8sRUFDUEMsV0FBVyxFQUNYQyxTQUFTLEVBQ1EsR0FiUzs7SUFjMUIsTUFBTUMsV0FBV2QsNkNBQU1BLENBQW1CO0lBQzFDLE1BQU1lLGlCQUFpQmYsNkNBQU1BLENBQVM7SUFDdEMsTUFBTWdCLGtCQUFrQmhCLDZDQUFNQSxDQUFTO0lBQ3ZDLE1BQU1pQixlQUFlakIsNkNBQU1BLENBQVU7SUFFckMsMkNBQTJDO0lBQzNDRCxnREFBU0E7aUNBQUM7WUFDUixNQUFNbUIsUUFBUUosU0FBU0ssT0FBTztZQUM5QixJQUFJLENBQUNELE9BQU87WUFFWkEsTUFBTWQsTUFBTSxHQUFHRSxVQUFVLElBQUlGO1lBQzdCYyxNQUFNRSxZQUFZLEdBQUdmO1FBQ3ZCO2dDQUFHO1FBQUNEO1FBQVFDO1FBQU9DO0tBQVE7SUFFM0IscURBQXFEO0lBQ3JEUCxnREFBU0E7aUNBQUM7WUFDUixNQUFNbUIsUUFBUUosU0FBU0ssT0FBTztZQUM5QixJQUFJLENBQUNELE9BQU87WUFFWixxRUFBcUU7WUFDckUsZ0ZBQWdGO1lBQ2hGLE1BQU1HLGlCQUFpQkMsS0FBS0MsR0FBRyxDQUFDTCxNQUFNWCxXQUFXLEdBQUdBO1lBQ3BELElBQUljLGlCQUFpQixLQUFLO2dCQUN4QkgsTUFBTVgsV0FBVyxHQUFHQTtZQUN0QjtRQUNGO2dDQUFHO1FBQUNBO0tBQVk7SUFFaEIseUNBQXlDO0lBQ3pDUixnREFBU0E7aUNBQUM7WUFDUixNQUFNbUIsUUFBUUosU0FBU0ssT0FBTztZQUM5QixJQUFJLENBQUNELE9B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ZUFBZUksT0FBTztZQUFFaUMsTUFBSzs7Ozs7Ozs7Ozs7QUFJbEQ7R0ExSWdCbkQ7S0FBQUEiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcYnJhZHlcXERlc2t0b3BcXFBvcnRmb2xpb1xcaGFjay10eC1tYW5nYS1uYXJyYXRpb25cXGZyb250ZW5kXFxjb21wb25lbnRzXFxBdWRpb1BsYXllci50c3giXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnXHJcblxyXG5pbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVJlZiB9IGZyb20gJ3JlYWN0JztcclxuXHJcbmludGVyZmFjZSBBdWRpb1BsYXllclByb3BzIHtcclxuICBhdWRpb1VybDogc3RyaW5nO1xyXG4gIGlzUGxheWluZzogYm9vbGVhbjtcclxuICB2b2x1bWU6IG51bWJlcjtcclxuICBzcGVlZDogbnVtYmVyO1xyXG4gIGlzTXV0ZWQ6IGJvb2xlYW47XHJcbiAgY3VycmVudFRpbWU6IG51bWJlcjtcclxuICBvblRpbWVVcGRhdGU6IChjdXJyZW50VGltZTogbnVtYmVyKSA9PiB2b2lkO1xyXG4gIG9uRHVyYXRpb25DaGFuZ2U6IChkdXJhdGlvbjogbnVtYmVyKSA9PiB2b2lkO1xyXG4gIG9uRW5kZWQ6ICgpID0+IHZvaWQ7XHJcbiAgb25FcnJvcjogKCkgPT4gdm9pZDtcclxuICBvbkxvYWRTdGFydD86ICgpID0+IHZvaWQ7XHJcbiAgb25DYW5QbGF5PzogKCkgPT4gdm9pZDtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIEF1ZGlvUGxheWVyKHsgXHJcbiAgYXVkaW9VcmwsIFxyXG4gIGlzUGxheWluZywgXHJcbiAgdm9sdW1lLCBcclxuICBzcGVlZCwgXHJcbiAgaXNNdXRlZCxcclxuICBjdXJyZW50VGltZSxcclxuICBvblRpbWVVcGRhdGUsXHJcbiAgb25EdXJhdGlvbkNoYW5nZSxcclxuICBvbkVuZGVkLFxyXG4gIG9uRXJyb3IsXHJcbiAgb25Mb2FkU3RhcnQsXHJcbiAgb25DYW5QbGF5XHJcbn06IEF1ZGlvUGxheWVyUHJvcHMpIHtcclxuICBjb25zdCBhdWRpb1JlZiA9IHVzZVJlZjxIVE1MQXVkaW9FbGVtZW50PihudWxsKTtcclxuICBjb25zdCBwcmV2aW91c1VybFJlZiA9IHVzZVJlZjxzdHJpbmc+KCcnKTtcclxuICBjb25zdCBsYXN0U2Vla1RpbWVSZWYgPSB1c2VSZWY8bnVtYmVyPigwKTtcclxuICBjb25zdCBpc1NlZWtpbmdSZWYgPSB1c2VSZWY8Ym9vbGVhbj4oZmFsc2UpO1xyXG5cclxuICAvLyBVcGRhdGUgYXVkaW8gcHJvcGVydGllcyB3aGVuIHRoZXkgY2hhbmdlXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGNvbnN0IGF1ZGlvID0gYXVkaW9SZWYuY3VycmVudDtcclxuICAgIGlmICghYXVkaW8pIHJldHVybjtcclxuXHJcbiAgICBhdWRpby52b2x1bWUgPSBpc011dGVkID8gMCA6IHZvbHVtZTtcclxuICAgIGF1ZGlvLnBsYXliYWNrUmF0ZSA9IHNwZWVkO1xyXG4gIH0sIFt2b2x1bWUsIHNwZWVkLCBpc011dGVkXSk7XHJcblxyXG4gIC8vIEhhbmRsZSBzZWVraW5nIHdoZW4gY3VycmVudFRpbWUgY2hhbmdlcyBleHRlcm5hbGx5XHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGNvbnN0IGF1ZGlvID0gYXVkaW9SZWYuY3VycmVudDtcclxuICAgIGlmICghYXVkaW8pIHJldHVybjtcclxuXHJcbiAgICAvLyBPbmx5IHNlZWsgaWYgdGhlIGRpZmZlcmVuY2UgaXMgc2lnbmlmaWNhbnQgKG1vcmUgdGhhbiAwLjUgc2Vjb25kcylcclxuICAgIC8vIFRoaXMgcHJldmVudHMgc3R1dHRlcmluZyBkdXJpbmcgbm9ybWFsIHBsYXliYWNrIHdoaWxlIGFsbG93aW5nIHByb3BlciBzZWVraW5nXHJcbiAgICBjb25zdCB0aW1lRGlmZmVyZW5jZSA9IE1hdGguYWJzKGF1ZGlvLmN1cnJlbnRUaW1lIC0gY3VycmVudFRpbWUpO1xyXG4gICAgaWYgKHRpbWVEaWZmZXJlbmNlID4gMC41KSB7XHJcbiAgICAgIGF1ZGlvLmN1cnJlbnRUaW1lID0gY3VycmVudFRpbWU7XHJcbiAgICB9XHJcbiAgfSwgW2N1cnJlbnRUaW1lXSk7XHJcblxyXG4gIC8vIEhhbmRsZSBwbGF5L3BhdXNlIHdpdGggcmVhZGluZXNzIGd1YXJkXHJcbiAgdXNlRWZmZWN0KCgpID0+IHtcclxuICAgIGNvbnN0IGF1ZGlvID0gYXVkaW9SZWYuY3VycmVudDtcclxuICAgIGlmICghYXVkaW8pIHJldHVybjtcclxuXHJcbiAgICBpZiAoaXNQbGF5aW5nKSB7XHJcbiAgICAgIC8vIElmIG5vdCByZWFkeSwgd2FpdCBmb3IgY2FucGxheSB0aGVuIGF0dGVtcHQgdG8gcGxheSBvbmNlXHJcbiAgICAgIGlmICghYXVkaW8uc3JjKSByZXR1cm47XHJcbiAgICAgIGNvbnN0IHRyeVBsYXkgPSAoKSA9PiB7XHJcbiAgICAgICAgYXVkaW8ucGxheSgpLmNhdGNoKChlcnJvcikgPT4ge1xyXG4gICAgICAgICAgaWYgKGVycm9yLm5hbWUgPT09ICdBYm9ydEVycm9yJykge1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZygnQXVkaW8gcGxheSB3YXMgYWJvcnRlZCAobGlrZWx5IGR1ZSB0byBzb3VyY2UgY2hhbmdlKScpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBwbGF5aW5nIGF1ZGlvOicsIGVycm9yKTtcclxuICAgICAgICAgIG9uRXJyb3IoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIGlmIChhdWRpby5yZWFkeVN0YXRlID49IDIpIHtcclxuICAgICAgICB0cnlQbGF5KCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29uc3Qgb25DYW5QbGF5T25jZSA9ICgpID0+IHtcclxuICAgICAgICAgIGF1ZGlvLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NhbnBsYXknLCBvbkNhblBsYXlPbmNlKTtcclxuICAgICAgICAgIHRyeVBsYXkoKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIGF1ZGlvLmFkZEV2ZW50TGlzdGVuZXIoJ2NhbnBsYXknLCBvbkNhblBsYXlPbmNlKTtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgYXVkaW8ucGF1c2UoKTtcclxuICAgIH1cclxuICB9LCBbaXNQbGF5aW5nLCBvbkVycm9yXSk7XHJcblxyXG4gIC8vIFNldCB1cCBldmVudCBsaXN0ZW5lcnNcclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgY29uc3QgYXVkaW8gPSBhdWRpb1JlZi5jdXJyZW50O1xyXG4gICAgaWYgKCFhdWRpbykgcmV0dXJuO1xyXG5cclxuICAgIGNvbnN0IGhhbmRsZVRpbWVVcGRhdGUgPSAoKSA9PiBvblRpbWVVcGRhdGUoYXVkaW8uY3VycmVudFRpbWUpO1xyXG4gICAgY29uc3QgaGFuZGxlTG9hZGVkTWV0YWRhdGEgPSAoKSA9PiBvbkR1cmF0aW9uQ2hhbmdlKGF1ZGlvLmR1cmF0aW9uKTtcclxuICAgIGNvbnN0IGhhbmRsZUVuZGVkID0gKCkgPT4gb25FbmRlZCgpO1xyXG4gICAgY29uc3QgaGFuZGxlRXJyb3IgPSAoKSA9PiB7XHJcbiAgICAgIC8vIFByZXZlbnQgbG9vcGluZyBjYXVzZWQgYnkgcmFwaWQgZXJyb3IgLT4gcGxheSBhdHRlbXB0c1xyXG4gICAgICBhdWRpby5wYXVzZSgpO1xyXG4gICAgICBvbkVycm9yKCk7XHJcbiAgICB9O1xyXG4gICAgY29uc3QgaGFuZGxlTG9hZFN0YXJ0ID0gKCkgPT4gb25Mb2FkU3RhcnQ/LigpO1xyXG4gICAgY29uc3QgaGFuZGxlQ2FuUGxheSA9ICgpID0+IG9uQ2FuUGxheT8uKCk7XHJcblxyXG4gICAgYXVkaW8uYWRkRXZlbnRMaXN0ZW5lcigndGltZXVwZGF0ZScsIGhhbmRsZVRpbWVVcGRhdGUpO1xyXG4gICAgYXVkaW8uYWRkRXZlbnRMaXN0ZW5lcignbG9hZGVkbWV0YWRhdGEnLCBoYW5kbGVMb2FkZWRNZXRhZGF0YSk7XHJcbiAgICBhdWRpby5hZGRFdmVudExpc3RlbmVyKCdlbmRlZCcsIGhhbmRsZUVuZGVkKTtcclxuICAgIGF1ZGlvLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgaGFuZGxlRXJyb3IpO1xyXG4gICAgYXVkaW8uYWRkRXZlbnRMaXN0ZW5lcignbG9hZHN0YXJ0JywgaGFuZGxlTG9hZFN0YXJ0KTtcclxuICAgIGF1ZGlvLmFkZEV2ZW50TGlzdGVuZXIoJ2NhbnBsYXknLCBoYW5kbGVDYW5QbGF5KTtcclxuXHJcbiAgICByZXR1cm4gKCkgPT4ge1xyXG4gICAgICBhdWRpby5yZW1vdmVFdmVudExpc3RlbmVyKCd0aW1ldXBkYXRlJywgaGFuZGxlVGltZVVwZGF0ZSk7XHJcbiAgICAgIGF1ZGlvLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2xvYWRlZG1ldGFkYXRhJywgaGFuZGxlTG9hZGVkTWV0YWRhdGEpO1xyXG4gICAgICBhdWRpby5yZW1vdmVFdmVudExpc3RlbmVyKCdlbmRlZCcsIGhhbmRsZUVuZGVkKTtcclxuICAgICAgYXVkaW8ucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBoYW5kbGVFcnJvcik7XHJcbiAgICAgIGF1ZGlvLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2xvYWRzdGFydCcsIGhhbmRsZUxvYWRTdGFydCk7XHJcbiAgICAgIGF1ZGlvLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NhbnBsYXknLCBoYW5kbGVDYW5QbGF5KTtcclxuICAgIH07XHJcbiAgfSwgW29uVGltZVVwZGF0ZSwgb25EdXJhdGlvbkNoYW5nZSwgb25FbmRlZCwgb25FcnJvciwgb25Mb2FkU3RhcnQsIG9uQ2FuUGxheV0pO1xyXG5cclxuICAvLyBVcGRhdGUgc3JjIHdoZW4gYXVkaW9VcmwgY2hhbmdlc1xyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBjb25zdCBhdWRpbyA9IGF1ZGlvUmVmLmN1cnJlbnQ7XHJcbiAgICBpZiAoIWF1ZGlvKSByZXR1cm47XHJcblxyXG4gICAgLy8gT25seSBjaGFuZ2Ugc291cmNlIGlmIHRoZSBVUkwgYWN0dWFsbHkgY2hhbmdlZFxyXG4gICAgaWYgKGF1ZGlvVXJsICYmIGF1ZGlvVXJsICE9PSBwcmV2aW91c1VybFJlZi5jdXJyZW50KSB7XHJcbiAgICAgIC8vIE5vcm1hbGl6ZSByZWxhdGl2ZSBVUkxzIHRvIHJvb3QtcmVsYXRpdmVcclxuICAgICAgY29uc3Qgbm9ybWFsaXplZFVybCA9IChhdWRpb1VybC5zdGFydHNXaXRoKCdodHRwJykgfHwgYXVkaW9Vcmwuc3RhcnRzV2l0aCgnLycpKVxyXG4gICAgICAgID8gYXVkaW9VcmxcclxuICAgICAgICA6IGAvJHthdWRpb1VybH1gO1xyXG4gICAgICAvLyBQYXVzZSBjdXJyZW50IGF1ZGlvIGJlZm9yZSBjaGFuZ2luZyBzb3VyY2UgdG8gcHJldmVudCBBYm9ydEVycm9yXHJcbiAgICAgIGF1ZGlvLnBhdXNlKCk7XHJcbiAgICAgIGF1ZGlvLnNyYyA9IG5vcm1hbGl6ZWRVcmw7XHJcbiAgICAgIGF1ZGlvLmxvYWQoKTtcclxuICAgICAgcHJldmlvdXNVcmxSZWYuY3VycmVudCA9IG5vcm1hbGl6ZWRVcmw7XHJcbiAgICB9XHJcbiAgfSwgW2F1ZGlvVXJsLCBvbkVycm9yXSk7XHJcblxyXG4gIHJldHVybiAoXHJcbiAgICA8YXVkaW9cclxuICAgICAgcmVmPXthdWRpb1JlZn1cclxuICAgICAgcHJlbG9hZD1cIm1ldGFkYXRhXCJcclxuICAgICAgc3R5bGU9e3sgZGlzcGxheTogJ25vbmUnIH19XHJcbiAgICA+XHJcbiAgICAgIHsvKiBQcm92aWRlIGEgc291cmNlIGVsZW1lbnQgd2l0aCB0eXBlIHRvIGhlbHAgYnJvd3NlciByZWNvZ25pemUgZm9ybWF0ICovfVxyXG4gICAgICB7cHJldmlvdXNVcmxSZWYuY3VycmVudCAmJiAoXHJcbiAgICAgICAgPHNvdXJjZSBzcmM9e3ByZXZpb3VzVXJsUmVmLmN1cnJlbnR9IHR5cGU9XCJhdWRpby9tcGVnXCIgLz5cclxuICAgICAgKX1cclxuICAgIDwvYXVkaW8+XHJcbiAgKTtcclxufVxyXG4iXSwibmFtZXMiOlsidXNlRWZmZWN0IiwidXNlUmVmIiwiQXVkaW9QbGF5ZXIiLCJhdWRpb1VybCIsImlzUGxheWluZyIsInZvbHVtZSIsInNwZWVkIiwiaXNNdXRlZCIsImN1cnJlbnRUaW1lIiwib25UaW1lVXBkYXRlIiwib25EdXJhdGlvbkNoYW5nZSIsIm9uRW5kZWQiLCJvbkVycm9yIiwib25Mb2FkU3RhcnQiLCJvbkNhblBsYXkiLCJhdWRpb1JlZiIsInByZXZpb3VzVXJsUmVmIiwibGFzdFNlZWtUaW1lUmVmIiwiaXNTZWVraW5nUmVmIiwiYXVkaW8iLCJjdXJyZW50IiwicGxheWJhY2tSYXRlIiwidGltZURpZmZlcmVuY2UiLCJNYXRoIiwiYWJzIiwic3JjIiwidHJ5UGxheSIsInBsYXkiLCJjYXRjaCIsImVycm9yIiwibmFtZSIsImNvbnNvbGUiLCJsb2ciLCJyZWFkeVN0YXRlIiwib25DYW5QbGF5T25jZSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJhZGRFdmVudExpc3RlbmVyIiwicGF1c2UiLCJoYW5kbGVUaW1lVXBkYXRlIiwiaGFuZGxlTG9hZGVkTWV0YWRhdGEiLCJkdXJhdGlvbiIsImhhbmRsZUVuZGVkIiwiaGFuZGxlRXJyb3IiLCJoYW5kbGVMb2FkU3RhcnQiLCJoYW5kbGVDYW5QbGF5Iiwibm9ybWFsaXplZFVybCIsInN0YXJ0c1dpdGgiLCJsb2FkIiwicmVmIiwicHJlbG9hZCIsInN0eWxlIiwiZGlzcGxheSIsInNvdXJjZSIsInR5cGUiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/AudioPlayer.tsx\n"));

/***/ })

});